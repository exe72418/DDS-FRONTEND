import { ɵmemoize, ɵgetStoreMetadata, ɵgetSelectorMetadata } from '@ngxs/store/internals';
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
export function createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {
    return (context) => {
        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);
        const { suppressErrors } = selectorOptions;
        return function selectFromRoot(rootState) {
            // Determine arguments from the app state using the selectors
            const results = argumentSelectorFunctions.map(argFn => argFn(rootState));
            // If the lambda attempts to access something in the state that doesn't exist,
            // it will throw a `TypeError`. Since this behavior is common, we simply return
            // `undefined` in such cases.
            try {
                return memoizedSelectorFn(...results);
            }
            catch (ex) {
                if (suppressErrors && ex instanceof TypeError) {
                    return undefined;
                }
                // We're logging an error in this function because it may be used by `select`,
                // `selectSignal`, and `selectSnapshot`. Therefore, there's no need to catch
                // exceptions there to log errors.
                if (NG_DEV_MODE) {
                    const message = 'The selector below has thrown an error upon invocation. ' +
                        'Please check for any unsafe property access that may result in null ' +
                        'or undefined values.';
                    // Avoid concatenating the message with the original function, as this will
                    // invoke `toString()` on the function. Instead, log it as the second argument.
                    // This way, developers will be able to navigate to the actual code in the browser.
                    console.error(message, selectorMetaData.originalFn);
                }
                throw ex;
            }
        };
    };
}
export function createMemoizedSelectorFn(originalFn, creationMetadata) {
    const containerClass = creationMetadata && creationMetadata.containerClass;
    const wrappedFn = function wrappedSelectorFn(...args) {
        const returnValue = originalFn.apply(containerClass, args);
        if (returnValue instanceof Function) {
            const innerMemoizedFn = ɵmemoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    const memoizedFn = ɵmemoize(wrappedFn);
    Object.setPrototypeOf(memoizedFn, originalFn);
    return memoizedFn;
}
function getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {
    const localSelectorOptions = selectorMetaData.getSelectorOptions();
    const selectorOptions = context.getSelectorOptions(localSelectorOptions);
    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);
    const argumentSelectorFunctions = selectorsToApply.map(selector => {
        const factory = getRootSelectorFactory(selector);
        return factory(context);
    });
    return {
        selectorOptions,
        argumentSelectorFunctions
    };
}
function getSelectorsToApply(selectors = [], selectorOptions, containerClass) {
    const selectorsToApply = [];
    // The container state refers to the state class that includes the
    // definition of the selector function, for example:
    // @State()
    // class AnimalsState {
    //   @Selector()
    //   static getAnimals(state: AnimalsStateModel) {}
    // }
    // The `AnimalsState` serves as the container state. Additionally, the
    // selector may reside within a namespace or another class lacking the
    // `@State` decorator, thus not being treated as the container state.
    const canInjectContainerState = selectorOptions.injectContainerState || selectors.length === 0;
    if (containerClass && canInjectContainerState) {
        // If we are on a state class, add it as the first selector parameter
        const metadata = ɵgetStoreMetadata(containerClass);
        if (metadata) {
            selectorsToApply.push(containerClass);
        }
    }
    selectorsToApply.push(...selectors);
    return selectorsToApply;
}
/**
 * This function gets the factory function to create the selector to get the selected slice from the app state
 * @ignore
 */
export function getRootSelectorFactory(selector) {
    const metadata = ɵgetSelectorMetadata(selector) || ɵgetStoreMetadata(selector);
    return (metadata && metadata.makeRootSelector) || (() => selector);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3ItdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yZS9zcmMvc2VsZWN0b3JzL3NlbGVjdG9yLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxRQUFRLEVBR1IsaUJBQWlCLEVBQ2pCLG9CQUFvQixFQUdyQixNQUFNLHVCQUF1QixDQUFDO0FBTS9CLE1BQU0sV0FBVyxHQUFHLE9BQU8sU0FBUyxLQUFLLFdBQVcsSUFBSSxTQUFTLENBQUM7QUFFbEUsTUFBTSxVQUFVLHlCQUF5QixDQUN2QyxnQkFBd0MsRUFDeEMsU0FBNEIsRUFDNUIsa0JBQXFCO0lBRXJCLE9BQU8sQ0FBQyxPQUFnQyxFQUFFLEVBQUU7UUFDMUMsTUFBTSxFQUFFLHlCQUF5QixFQUFFLGVBQWUsRUFBRSxHQUFHLHNCQUFzQixDQUMzRSxPQUFPLEVBQ1AsZ0JBQWdCLEVBQ2hCLFNBQVMsQ0FDVixDQUFDO1FBRUYsTUFBTSxFQUFFLGNBQWMsRUFBRSxHQUFHLGVBQWUsQ0FBQztRQUUzQyxPQUFPLFNBQVMsY0FBYyxDQUFDLFNBQWM7WUFDM0MsNkRBQTZEO1lBQzdELE1BQU0sT0FBTyxHQUFHLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBRXpFLDhFQUE4RTtZQUM5RSwrRUFBK0U7WUFDL0UsNkJBQTZCO1lBQzdCLElBQUksQ0FBQztnQkFDSCxPQUFPLGtCQUFrQixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7WUFDeEMsQ0FBQztZQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7Z0JBQ1osSUFBSSxjQUFjLElBQUksRUFBRSxZQUFZLFNBQVMsRUFBRSxDQUFDO29CQUM5QyxPQUFPLFNBQVMsQ0FBQztnQkFDbkIsQ0FBQztnQkFFRCw4RUFBOEU7Z0JBQzlFLDRFQUE0RTtnQkFDNUUsa0NBQWtDO2dC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QyxPQUFPLGdCQUFnQixDQUFDO0FBQzFCLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsUUFBYTtJQUNsRCxNQUFNLFFBQVEsR0FBRyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMvRSxPQUFPLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIMm1bWVtb2l6ZSxcbiAgybVSdW50aW1lU2VsZWN0b3JDb250ZXh0LFxuICDJtVNlbGVjdG9yRmFjdG9yeSxcbiAgybVnZXRTdG9yZU1ldGFkYXRhLFxuICDJtWdldFNlbGVjdG9yTWV0YWRhdGEsXG4gIMm1U2VsZWN0b3JNZXRhRGF0YU1vZGVsLFxuICDJtVNoYXJlZFNlbGVjdG9yT3B0aW9uc1xufSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuXG5pbXBvcnQgeyBDcmVhdGlvbk1ldGFkYXRhLCBSdW50aW1lU2VsZWN0b3JJbmZvIH0gZnJvbSAnLi9zZWxlY3Rvci1tb2RlbHMnO1xuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlICE9PSAndW5kZWZpbmVkJyAmJiBuZ0Rldk1vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb290U2VsZWN0b3JGYWN0b3J5PFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIHNlbGVjdG9yTWV0YURhdGE6IMm1U2VsZWN0b3JNZXRhRGF0YU1vZGVsLFxuICBzZWxlY3RvcnM6IGFueVtdIHwgdW5kZWZpbmVkLFxuICBtZW1vaXplZFNlbGVjdG9yRm46IFRcbik6IMm1U2VsZWN0b3JGYWN0b3J5IHtcbiAgcmV0dXJuIChjb250ZXh0OiDJtVJ1bnRpbWVTZWxlY3RvckNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnMsIHNlbGVjdG9yT3B0aW9ucyB9ID0gZ2V0UnVudGltZVNlbGVjdG9ySW5mbyhcbiAgICAgIGNvbnRleHQsXG4gICAgICBzZWxlY3Rvck1ldGFEYXRhLFxuICAgICAgc2VsZWN0b3JzXG4gICAgKTtcblxuICAgIGNvbnN0IHsgc3VwcHJlc3NFcnJvcnMgfSA9IHNlbGVjdG9yT3B0aW9ucztcblxuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RGcm9tUm9vdChyb290U3RhdGU6IGFueSkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGFyZ3VtZW50cyBmcm9tIHRoZSBhcHAgc3RhdGUgdXNpbmcgdGhlIHNlbGVjdG9yc1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnMubWFwKGFyZ0ZuID0+IGFyZ0ZuKHJvb3RTdGF0ZSkpO1xuXG4gICAgICAvLyBJZiB0aGUgbGFtYmRhIGF0dGVtcHRzIHRvIGFjY2VzcyBzb21ldGhpbmcgaW4gdGhlIHN0YXRlIHRoYXQgZG9lc24ndCBleGlzdCxcbiAgICAgIC8vIGl0IHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYC4gU2luY2UgdGhpcyBiZWhhdmlvciBpcyBjb21tb24sIHdlIHNpbXBseSByZXR1cm5cbiAgICAgIC8vIGB1bmRlZmluZWRgIGluIHN1Y2ggY2FzZXMuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvckZuKC4uLnJlc3VsdHMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzRXJyb3JzICYmIGV4IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlJ3JlIGxvZ2dpbmcgYW4gZXJyb3IgaW4gdGhpcyBmdW5jdGlvbiBiZWNhdXNlIGl0IG1heSBiZSB1c2VkIGJ5IGBzZWxlY3RgLFxuICAgICAgICAvLyBgc2VsZWN0U2lnbmFsYCwgYW5kIGBzZWxlY3RTbmFwc2hvdGAuIFRoZXJlZm9yZSwgdGhlcmUncyBubyBuZWVkIHRvIGNhdGNoXG4gICAgICAgIC8vIGV4Y2VwdGlvbnMgdGhlcmUgdG8gbG9nIGVycm9ycy5cbiAgICAgICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAnVGhlIHNlbGVjdG9yIGJlbG93IGhhcyB0aHJvd24gYW4gZXJyb3IgdXBvbiBpbnZvY2F0aW9uLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgY2hlY2sgZm9yIGFueSB1bnNhZmUgcHJvcGVydHkgYWNjZXNzIHRoYXQgbWF5IHJlc3VsdCBpbiBudWxsICcgK1xuICAgICAgICAgICAgJ29yIHVuZGVmaW5lZCB2YWx1ZXMuJztcblxuICAgICAgICAgIC8vIEF2b2lkIGNvbmNhdGVuYXRpbmcgdGhlIG1lc3NhZ2Ugd2l0aCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24sIGFzIHRoaXMgd2lsbFxuICAgICAgICAgIC8vIGludm9rZSBgdG9TdHJpbmcoKWAgb24gdGhlIGZ1bmN0aW9uLiBJbnN0ZWFkLCBsb2cgaXQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgICAgICAvLyBUaGlzIHdheSwgZGV2ZWxvcGVycyB3aWxsIGJlIGFibGUgdG8gbmF2aWdhdGUgdG8gdGhlIGFjdHVhbCBjb2RlIGluIHRoZSBicm93c2VyLlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vaXplZFNlbGVjdG9yRm48VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgb3JpZ2luYWxGbjogVCxcbiAgY3JlYXRpb25NZXRhZGF0YTogUGFydGlhbDxDcmVhdGlvbk1ldGFkYXRhPiB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YSAmJiBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbiguLi5hcmdzOiBhbnlbXSkge1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3JpZ2luYWxGbi5hcHBseShjb250YWluZXJDbGFzcywgYXJncyk7XG4gICAgaWYgKHJldHVyblZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNvbnN0IGlubmVyTWVtb2l6ZWRGbiA9IMm1bWVtb2l6ZS5hcHBseShudWxsLCBbcmV0dXJuVmFsdWVdKTtcbiAgICAgIHJldHVybiBpbm5lck1lbW9pemVkRm47XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfSBhcyBUO1xuICBjb25zdCBtZW1vaXplZEZuID0gybVtZW1vaXplKHdyYXBwZWRGbik7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihtZW1vaXplZEZuLCBvcmlnaW5hbEZuKTtcbiAgcmV0dXJuIG1lbW9pemVkRm47XG59XG5cbmZ1bmN0aW9uIGdldFJ1bnRpbWVTZWxlY3RvckluZm8oXG4gIGNvbnRleHQ6IMm1UnVudGltZVNlbGVjdG9yQ29udGV4dCxcbiAgc2VsZWN0b3JNZXRhRGF0YTogybVTZWxlY3Rvck1ldGFEYXRhTW9kZWwsXG4gIHNlbGVjdG9yczogYW55W10gfCB1bmRlZmluZWQgPSBbXVxuKTogUnVudGltZVNlbGVjdG9ySW5mbyB7XG4gIGNvbnN0IGxvY2FsU2VsZWN0b3JPcHRpb25zID0gc2VsZWN0b3JNZXRhRGF0YS5nZXRTZWxlY3Rvck9wdGlvbnMoKTtcbiAgY29uc3Qgc2VsZWN0b3JPcHRpb25zID0gY29udGV4dC5nZXRTZWxlY3Rvck9wdGlvbnMobG9jYWxTZWxlY3Rvck9wdGlvbnMpO1xuICBjb25zdCBzZWxlY3RvcnNUb0FwcGx5ID0gZ2V0U2VsZWN0b3JzVG9BcHBseShcbiAgICBzZWxlY3RvcnMsXG4gICAgc2VsZWN0b3JPcHRpb25zLFxuICAgIHNlbGVjdG9yTWV0YURhdGEuY29udGFpbmVyQ2xhc3NcbiAgKTtcblxuICBjb25zdCBhcmd1bWVudFNlbGVjdG9yRnVuY3Rpb25zID0gc2VsZWN0b3JzVG9BcHBseS5tYXAoc2VsZWN0b3IgPT4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBnZXRSb290U2VsZWN0b3JGYWN0b3J5KHNlbGVjdG9yKTtcbiAgICByZXR1cm4gZmFjdG9yeShjb250ZXh0KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JPcHRpb25zLFxuICAgIGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JzVG9BcHBseShcbiAgc2VsZWN0b3JzOiBhbnlbXSB8IHVuZGVmaW5lZCA9IFtdLFxuICBzZWxlY3Rvck9wdGlvbnM6IMm1U2hhcmVkU2VsZWN0b3JPcHRpb25zLFxuICBjb250YWluZXJDbGFzczogYW55XG4pIHtcbiAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IFtdO1xuICAvLyBUaGUgY29udGFpbmVyIHN0YXRlIHJlZmVycyB0byB0aGUgc3RhdGUgY2xhc3MgdGhhdCBpbmNsdWRlcyB0aGVcbiAgLy8gZGVmaW5pdGlvbiBvZiB0aGUgc2VsZWN0b3IgZnVuY3Rpb24sIGZvciBleGFtcGxlOlxuICAvLyBAU3RhdGUoKVxuICAvLyBjbGFzcyBBbmltYWxzU3RhdGUge1xuICAvLyAgIEBTZWxlY3RvcigpXG4gIC8vICAgc3RhdGljIGdldEFuaW1hbHMoc3RhdGU6IEFuaW1hbHNTdGF0ZU1vZGVsKSB7fVxuICAvLyB9XG4gIC8vIFRoZSBgQW5pbWFsc1N0YXRlYCBzZXJ2ZXMgYXMgdGhlIGNvbnRhaW5lciBzdGF0ZS4gQWRkaXRpb25hbGx5LCB0aGVcbiAgLy8gc2VsZWN0b3IgbWF5IHJlc2lkZSB3aXRoaW4gYSBuYW1lc3BhY2Ugb3IgYW5vdGhlciBjbGFzcyBsYWNraW5nIHRoZVxuICAvLyBgQFN0YXRlYCBkZWNvcmF0b3IsIHRodXMgbm90IGJlaW5nIHRyZWF0ZWQgYXMgdGhlIGNvbnRhaW5lciBzdGF0ZS5cbiAgY29uc3QgY2FuSW5qZWN0Q29udGFpbmVyU3RhdGUgPVxuICAgIHNlbGVjdG9yT3B0aW9ucy5pbmplY3RDb250YWluZXJTdGF0ZSB8fCBzZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuXG4gIGlmIChjb250YWluZXJDbGFzcyAmJiBjYW5JbmplY3RDb250YWluZXJTdGF0ZSkge1xuICAgIC8vIElmIHdlIGFyZSBvbiBhIHN0YXRlIGNsYXNzLCBhZGQgaXQgYXMgdGhlIGZpcnN0IHNlbGVjdG9yIHBhcmFtZXRlclxuICAgIGNvbnN0IG1ldGFkYXRhID0gybVnZXRTdG9yZU1ldGFkYXRhKGNvbnRhaW5lckNsYXNzKTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIHNlbGVjdG9yc1RvQXBwbHkucHVzaChjb250YWluZXJDbGFzcyk7XG4gICAgfVxuICB9XG4gIHNlbGVjdG9yc1RvQXBwbHkucHVzaCguLi5zZWxlY3RvcnMpO1xuICByZXR1cm4gc2VsZWN0b3JzVG9BcHBseTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBzZWxlY3RvciB0byBnZXQgdGhlIHNlbGVjdGVkIHNsaWNlIGZyb20gdGhlIGFwcCBzdGF0ZVxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um9vdFNlbGVjdG9yRmFjdG9yeShzZWxlY3RvcjogYW55KTogybVTZWxlY3RvckZhY3Rvcnkge1xuICBjb25zdCBtZXRhZGF0YSA9IMm1Z2V0U2VsZWN0b3JNZXRhZGF0YShzZWxlY3RvcikgfHwgybVnZXRTdG9yZU1ldGFkYXRhKHNlbGVjdG9yKTtcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5tYWtlUm9vdFNlbGVjdG9yKSB8fCAoKCkgPT4gc2VsZWN0b3IpO1xufVxuIl19