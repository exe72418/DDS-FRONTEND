import { computed, Inject, Injectable, Optional } from '@angular/core';
import { of, throwError, catchError, distinctUntilChanged, map, shareReplay, take } from 'rxjs';
import { ɵINITIAL_STATE_TOKEN, ɵStateStream } from '@ngxs/store/internals';
import { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';
import { InternalStateOperations } from './internal/state-operations';
import { getRootSelectorFactory } from './selectors/selector-utils';
import { leaveNgxs } from './operators/leave-ngxs';
import { NgxsConfig } from './symbols';
import { StateFactory } from './internal/state-factory';
import * as i0 from "@angular/core";
import * as i1 from "@ngxs/store/internals";
import * as i2 from "./internal/state-operations";
import * as i3 from "./symbols";
import * as i4 from "./execution/internal-ngxs-execution-strategy";
import * as i5 from "./internal/state-factory";
export class Store {
    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
        this._config = _config;
        this._internalExecutionStrategy = _internalExecutionStrategy;
        this._stateFactory = _stateFactory;
        /**
         * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
         * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
         * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
         */
        this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));
        this.initStateStream(initialStateValue);
    }
    /**
     * Dispatches event(s).
     */
    dispatch(actionOrActions) {
        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);
    }
    /**
     * Selects a slice of data from the store.
     */
    select(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return this._selectableStateStream.pipe(map(selectorFn), catchError((error) => {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (this._config.selectorOptions.suppressErrors && error instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            return throwError(error);
        }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));
    }
    /**
     * Select one slice of data from the store.
     */
    selectOnce(selector) {
        return this.select(selector).pipe(take(1));
    }
    /**
     * Select a snapshot from the state.
     */
    selectSnapshot(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    }
    /**
     * Select a signal from the state.
     */
    selectSignal(selector) {
        const selectorFn = this.getStoreBoundSelectorFn(selector);
        return computed(() => selectorFn(this._stateStream.state()));
    }
    /**
     * Allow the user to subscribe to the root of the state
     */
    subscribe(fn) {
        return this._selectableStateStream
            .pipe(leaveNgxs(this._internalExecutionStrategy))
            .subscribe(fn);
    }
    /**
     * Return the raw value of the state.
     */
    snapshot() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    reset(state) {
        this._internalStateOperations.getRootStateOperations().setState(state);
    }
    getStoreBoundSelectorFn(selector) {
        const makeSelectorFn = getRootSelectorFactory(selector);
        const runtimeContext = this._stateFactory.getRuntimeSelectorContext();
        return makeSelectorFn(runtimeContext);
    }
    initStateStream(initialStateValue) {
        const value = this._stateStream.value;
        const storeIsEmpty = !value || Object.keys(value).length === 0;
        if (storeIsEmpty) {
            this._stateStream.next(initialStateValue);
        }
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: Store, deps: [{ token: i1.ɵStateStream }, { token: i2.InternalStateOperations }, { token: i3.NgxsConfig }, { token: i4.InternalNgxsExecutionStrategy }, { token: i5.StateFactory }, { token: ɵINITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: Store, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: Store, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i1.ɵStateStream }, { type: i2.InternalStateOperations }, { type: i3.NgxsConfig }, { type: i4.InternalNgxsExecutionStrategy }, { type: i5.StateFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ɵINITIAL_STATE_TOKEN]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yZS9zcmMvc3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUMvRSxPQUFPLEVBRUwsRUFBRSxFQUVGLFVBQVUsRUFDVixVQUFVLEVBQ1Ysb0JBQW9CLEVBQ3BCLEdBQUcsRUFDSCxXQUFXLEVBQ1gsSUFBSSxFQUNMLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTNFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBQzdGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7OztBQUl4RCxNQUFNLE9BQU8sS0FBSztJQVdoQixZQUNVLFlBQTBCLEVBQzFCLHdCQUFpRCxFQUNqRCxPQUFtQixFQUNuQiwwQkFBeUQsRUFDekQsYUFBMkIsRUFHbkMsaUJBQXNCO1FBUGQsaUJBQVksR0FBWixZQUFZLENBQWM7UUFDMUIsNkJBQXdCLEdBQXhCLHdCQUF3QixDQUF5QjtRQUNqRCxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ25CLCtCQUEwQixHQUExQiwwQkFBMEIsQ0FBK0I7UUFDekQsa0JBQWEsR0FBYixhQUFhLENBQWM7UUFmckM7Ozs7V0FJRztRQUNLLDJCQUFzQixHQUFHLElBQUks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QUFlLENBQUMsaUJBQXNCO1FBQzVDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDO1FBQ3RDLE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztRQUUvRCxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDNUMsQ0FBQztJQUNILENBQUM7aUlBaEhVLEtBQUssd0xBa0JOLG9CQUFvQjtxSUFsQm5CLEtBQUssY0FEUSxNQUFNOzsyRkFDbkIsS0FBSztrQkFEakIsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OzBCQWtCN0IsUUFBUTs7MEJBQ1IsTUFBTTsyQkFBQyxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wdXRlZCwgSW5qZWN0LCBJbmplY3RhYmxlLCBPcHRpb25hbCwgU2lnbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBPYnNlcnZhYmxlLFxuICBvZixcbiAgU3Vic2NyaXB0aW9uLFxuICB0aHJvd0Vycm9yLFxuICBjYXRjaEVycm9yLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgbWFwLFxuICBzaGFyZVJlcGxheSxcbiAgdGFrZVxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7IMm1SU5JVElBTF9TVEFURV9UT0tFTiwgybVTdGF0ZVN0cmVhbSB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5cbmltcG9ydCB7IEludGVybmFsTmd4c0V4ZWN1dGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9leGVjdXRpb24vaW50ZXJuYWwtbmd4cy1leGVjdXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgZ2V0Um9vdFNlbGVjdG9yRmFjdG9yeSB9IGZyb20gJy4vc2VsZWN0b3JzL3NlbGVjdG9yLXV0aWxzJztcbmltcG9ydCB7IGxlYXZlTmd4cyB9IGZyb20gJy4vb3BlcmF0b3JzL2xlYXZlLW5neHMnO1xuaW1wb3J0IHsgTmd4c0NvbmZpZyB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgeyBTdGF0ZUZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWZhY3RvcnknO1xuaW1wb3J0IHsgVHlwZWRTZWxlY3RvciB9IGZyb20gJy4vc2VsZWN0b3JzJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBTdG9yZSB7XG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgZGVyaXZlZCBzdGF0ZSBzdHJlYW0gdGhhdCBsZWF2ZXMgTkdYUyBleGVjdXRpb24gc3RyYXRlZ3kgdG8gZW1pdCBzdGF0ZSBjaGFuZ2VzIHdpdGhpbiB0aGUgQW5ndWxhciB6b25lLFxuICAgKiBiZWNhdXNlIHN0YXRlIGlzIGJlaW5nIGNoYW5nZWQgYWN0dWFsbHkgd2l0aGluIHRoZSBgPHJvb3Q+YCB6b25lLCBzZWUgYEludGVybmFsRGlzcGF0Y2hlciNkaXNwYXRjaFNpbmdsZWAuXG4gICAqIEFsbCBzZWxlY3RzIHdvdWxkIHVzZSB0aGlzIHN0cmVhbSwgYW5kIGl0IHdvdWxkIGNhbGwgbGVhdmUgb25seSBvbmNlIGZvciBhbnkgc3RhdGUgY2hhbmdlIGFjcm9zcyBhbGwgYWN0aXZlIHNlbGVjdG9ycy5cbiAgICovXG4gIHByaXZhdGUgX3NlbGVjdGFibGVTdGF0ZVN0cmVhbSA9IHRoaXMuX3N0YXRlU3RyZWFtLnBpcGUoXG4gICAgbGVhdmVOZ3hzKHRoaXMuX2ludGVybmFsRXhlY3V0aW9uU3RyYXRlZ3kpLFxuICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSlcbiAgKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogybVTdGF0ZVN0cmVhbSxcbiAgICBwcml2YXRlIF9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMsXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxuICAgIHByaXZhdGUgX2ludGVybmFsRXhlY3V0aW9uU3RyYXRlZ3k6IEludGVybmFsTmd4c0V4ZWN1dGlvblN0cmF0ZWd5LFxuICAgIHByaXZhdGUgX3N0YXRlRmFjdG9yeTogU3RhdGVGYWN0b3J5LFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdCjJtUlOSVRJQUxfU1RBVEVfVE9LRU4pXG4gICAgaW5pdGlhbFN0YXRlVmFsdWU6IGFueVxuICApIHtcbiAgICB0aGlzLmluaXRTdGF0ZVN0cmVhbShpbml0aWFsU3RhdGVWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBldmVudChzKS5cbiAgICovXG4gIGRpc3BhdGNoKGFjdGlvbk9yQWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpLmRpc3BhdGNoKGFjdGlvbk9yQWN0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyBhIHNsaWNlIG9mIGRhdGEgZnJvbSB0aGUgc3RvcmUuXG4gICAqL1xuICBzZWxlY3Q8VD4oc2VsZWN0b3I6IFR5cGVkU2VsZWN0b3I8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBjb25zdCBzZWxlY3RvckZuID0gdGhpcy5nZXRTdG9yZUJvdW5kU2VsZWN0b3JGbihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGFibGVTdGF0ZVN0cmVhbS5waXBlKFxuICAgICAgbWFwKHNlbGVjdG9yRm4pLFxuICAgICAgY2F0Y2hFcnJvcigoZXJyb3I6IEVycm9yKTogT2JzZXJ2YWJsZTxuZXZlcj4gfCBPYnNlcnZhYmxlPHVuZGVmaW5lZD4gPT4ge1xuICAgICAgICAvLyBpZiBlcnJvciBpcyBUeXBlRXJyb3Igd2Ugc3dhbGxvdyBpdCB0byBwcmV2ZW50IHVzdWFsIGVycm9ycyB3aXRoIHByb3BlcnR5IGFjY2Vzc1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLnNlbGVjdG9yT3B0aW9ucy5zdXBwcmVzc0Vycm9ycyAmJiBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0aHJvdyBvdGhlciBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IpO1xuICAgICAgfSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgbGVhdmVOZ3hzKHRoaXMuX2ludGVybmFsRXhlY3V0aW9uU3RyYXRlZ3kpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3Qgb25lIHNsaWNlIG9mIGRhdGEgZnJvbSB0aGUgc3RvcmUuXG4gICAqL1xuICBzZWxlY3RPbmNlPFQ+KHNlbGVjdG9yOiBUeXBlZFNlbGVjdG9yPFQ+KTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KHNlbGVjdG9yKS5waXBlKHRha2UoMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHNuYXBzaG90IGZyb20gdGhlIHN0YXRlLlxuICAgKi9cbiAgc2VsZWN0U25hcHNob3Q8VD4oc2VsZWN0b3I6IFR5cGVkU2VsZWN0b3I8VD4pOiBUIHtcbiAgICBjb25zdCBzZWxlY3RvckZuID0gdGhpcy5nZXRTdG9yZUJvdW5kU2VsZWN0b3JGbihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHNlbGVjdG9yRm4odGhpcy5fc3RhdGVTdHJlYW0uZ2V0VmFsdWUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc2lnbmFsIGZyb20gdGhlIHN0YXRlLlxuICAgKi9cbiAgc2VsZWN0U2lnbmFsPFQ+KHNlbGVjdG9yOiBUeXBlZFNlbGVjdG9yPFQ+KTogU2lnbmFsPFQ+IHtcbiAgICBjb25zdCBzZWxlY3RvckZuID0gdGhpcy5nZXRTdG9yZUJvdW5kU2VsZWN0b3JGbihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIGNvbXB1dGVkPFQ+KCgpID0+IHNlbGVjdG9yRm4odGhpcy5fc3RhdGVTdHJlYW0uc3RhdGUoKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHRoZSB1c2VyIHRvIHN1YnNjcmliZSB0byB0aGUgcm9vdCBvZiB0aGUgc3RhdGVcbiAgICovXG4gIHN1YnNjcmliZShmbj86ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZVN0YXRlU3RyZWFtXG4gICAgICAucGlwZShsZWF2ZU5neHModGhpcy5faW50ZXJuYWxFeGVjdXRpb25TdHJhdGVneSkpXG4gICAgICAuc3Vic2NyaWJlKGZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHJhdyB2YWx1ZSBvZiB0aGUgc3RhdGUuXG4gICAqL1xuICBzbmFwc2hvdCgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc3RhdGUgdG8gYSBzcGVjaWZpYyBwb2ludCBpbiB0aW1lLiBUaGlzIG1ldGhvZCBpcyB1c2VmdWxcbiAgICogZm9yIHBsdWdpbidzIHdobyBuZWVkIHRvIG1vZGlmeSB0aGUgc3RhdGUgZGlyZWN0bHkgb3IgdW5pdCB0ZXN0aW5nLlxuICAgKi9cbiAgcmVzZXQoc3RhdGU6IGFueSkge1xuICAgIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5zZXRTdGF0ZShzdGF0ZSk7XG4gIH1cblxuICBwcml2YXRlIGdldFN0b3JlQm91bmRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpIHtcbiAgICBjb25zdCBtYWtlU2VsZWN0b3JGbiA9IGdldFJvb3RTZWxlY3RvckZhY3Rvcnkoc2VsZWN0b3IpO1xuICAgIGNvbnN0IHJ1bnRpbWVDb250ZXh0ID0gdGhpcy5fc3RhdGVGYWN0b3J5LmdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQoKTtcbiAgICByZXR1cm4gbWFrZVNlbGVjdG9yRm4ocnVudGltZUNvbnRleHQpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0U3RhdGVTdHJlYW0oaW5pdGlhbFN0YXRlVmFsdWU6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fc3RhdGVTdHJlYW0udmFsdWU7XG4gICAgY29uc3Qgc3RvcmVJc0VtcHR5ID0gIXZhbHVlIHx8IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDA7XG5cbiAgICBpZiAoc3RvcmVJc0VtcHR5KSB7XG4gICAgICB0aGlzLl9zdGF0ZVN0cmVhbS5uZXh0KGluaXRpYWxTdGF0ZVZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==