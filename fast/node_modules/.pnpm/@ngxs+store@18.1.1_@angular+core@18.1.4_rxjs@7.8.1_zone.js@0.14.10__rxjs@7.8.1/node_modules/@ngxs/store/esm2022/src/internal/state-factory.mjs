import { Injectable, Injector, Optional, SkipSelf, Inject, ɵisPromise, inject } from '@angular/core';
import { ɵmemoize, ɵMETA_KEY, ɵgetStoreMetadata, ɵINITIAL_STATE_TOKEN } from '@ngxs/store/internals';
import { getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';
import { forkJoin, from, of, throwError, Subject, isObservable } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, nameToState, ɵPROP_GETTER, topologicalSort } from './internals';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { ensureStateNameIsUnique, ensureStatesAreDecorated } from '../utils/store-validators';
import { ensureStateClassIsInjectable } from '../ivy/ivy-enabled-in-dev-mode';
import { NgxsUnhandledActionsLogger } from '../dev-features/ngxs-unhandled-actions-logger';
import { NgxsUnhandledErrorHandler } from '../ngxs-unhandled-error-handler';
import { assignUnhandledCallback } from './unhandled-rxjs-error-callback';
import * as i0 from "@angular/core";
import * as i1 from "../symbols";
import * as i2 from "../actions-stream";
import * as i3 from "../internal/dispatcher";
import * as i4 from "../internal/state-context-factory";
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
function cloneDefaults(defaults) {
    let value = defaults === undefined ? {} : defaults;
    if (defaults) {
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (typeof defaults === 'object') {
            value = { ...defaults };
        }
    }
    return value;
}
/**
 * The `StateFactory` class adds root and feature states to the graph.
 * This extracts state names from state classes, checks if they already
 * exist in the global graph, throws errors if their names are invalid, etc.
 * See its constructor, state factories inject state factories that are
 * parent-level providers. This is required to get feature states from the
 * injector on the same level.
 *
 * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.
 * The `StateFactory` is initialized on the feature level and goes through `...states`
 * to get them from the injector through `injector.get(state)`.
 * @ignore
 */
export class StateFactory {
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._actionsSubscription = null;
        this._propGetter = inject(ɵPROP_GETTER);
        this._ngxsUnhandledErrorHandler = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = ɵmemoize(() => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const stateFactory = this;
            const propGetter = stateFactory._propGetter;
            function resolveGetter(key) {
                const path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.')) : null;
            }
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter(key) {
                        // Use `@__INLINE__` annotation to forcely inline `resolveGetter`.
                        // This is a Terser annotation, which will function only in the production mode.
                        let getter = /*@__INLINE__*/ resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (...args) => {
                            // Late loaded getter
                            if (!getter) {
                                getter = /*@__INLINE__*/ resolveGetter(key);
                            }
                            return getter ? getter(...args) : undefined;
                        };
                    },
                    getSelectorOptions(localOptions) {
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return {
                            ...globalSelectorOptions,
                            ...(localOptions || {})
                        };
                    }
                };
            return context;
        });
    }
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    ngOnDestroy() {
        this._actionsSubscription?.unsubscribe();
    }
    /**
     * Add a new state to the global defs.
     */
    add(stateClasses) {
        if (NG_DEV_MODE) {
            ensureStatesAreDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        const stateGraph = buildGraph(newStates);
        const sortedStates = topologicalSort(stateGraph);
        const paths = findFullParentPath(stateGraph);
        const nameGraph = nameToState(newStates);
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            const stateClass = nameGraph[name];
            const path = paths[name];
            const meta = stateClass[ɵMETA_KEY];
            this.addRuntimeInfoToMeta(meta, path);
            // Note: previously we called `ensureStateClassIsInjectable` within the
            // `State` decorator. This check is moved here because the `ɵprov` property
            // will not exist on the class in JIT mode (because it's set asynchronously
            // during JIT compilation through `Object.defineProperty`).
            if (NG_DEV_MODE) {
                ensureStateClassIsInjectable(stateClass);
            }
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     */
    addAndReturnDefaults(stateClasses) {
        const classes = stateClasses || [];
        const mappedStores = this.add(classes);
        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});
        return { defaults, states: mappedStores };
    }
    connectActionHandlers() {
        // Note: We have to connect actions only once when the `StateFactory`
        //       is being created for the first time. This checks if we're in
        //       a child state factory and the parent state factory already exists.
        if (this._parentFactory || this._actionsSubscription !== null) {
            return;
        }
        const dispatched$ = new Subject();
        this._actionsSubscription = this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* ActionStatus.Dispatched */), mergeMap(ctx => {
            dispatched$.next(ctx);
            const action = ctx.action;
            return this.invokeActions(dispatched$, action).pipe(map(() => ({ action, status: "SUCCESSFUL" /* ActionStatus.Successful */ })), defaultIfEmpty({ action, status: "CANCELED" /* ActionStatus.Canceled */ }), catchError(error => {
                const ngxsUnhandledErrorHandler = (this._ngxsUnhandledErrorHandler ||=
                    this._injector.get(NgxsUnhandledErrorHandler));
                const handleableError = assignUnhandledCallback(error, () => ngxsUnhandledErrorHandler.handleError(error, { action }));
                return of({
                    action,
                    status: "ERRORED" /* ActionStatus.Errored */,
                    error: handleableError
                });
            }));
        }))
            .subscribe(ctx => this._actionResults.next(ctx));
    }
    /**
     * Invoke actions on the states.
     */
    invokeActions(dispatched$, action) {
        const type = getActionTypeFromInstance(action);
        const results = [];
        // Determines whether the dispatched action has been handled, this is assigned
        // to `true` within the below `for` loop if any `actionMetas` has been found.
        let actionHasBeenHandled = false;
        for (const metadata of this.states) {
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        // We need to use `isPromise` instead of checking whether
                        // `result instanceof Promise`. In zone.js patched environments, `global.Promise`
                        // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js
                        // for certain reasons, might not work with `instanceof`. For instance, the dynamic
                        // import returns a native promise (not a `ZoneAwarePromise`), causing this check to
                        // be falsy.
                        if (ɵisPromise(result)) {
                            result = from(result);
                        }
                        if (isObservable(result)) {
                            // If this observable has been completed w/o emitting
                            // any value then we wouldn't want to complete the whole chain
                            // of actions. Since if any observable completes then
                            // action will be canceled.
                            // For instance if any action handler would've had such statement:
                            // `handler(ctx) { return EMPTY; }`
                            // then the action will be canceled.
                            // See https://github.com/ngxs/store/issues/1568
                            result = result.pipe(mergeMap((value) => {
                                if (ɵisPromise(value)) {
                                    return from(value);
                                }
                                if (isObservable(value)) {
                                    return value;
                                }
                                return of(value);
                            }), defaultIfEmpty({}));
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                    actionHasBeenHandled = true;
                }
            }
        }
        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions
        // only during development.
        if (NG_DEV_MODE && !actionHasBeenHandled) {
            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);
            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the
            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`
            // didn't return `null` so we may ensure the module has been imported.
            if (unhandledActionsLogger) {
                unhandledActionsLogger.warn(action);
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    addToStatesMap(stateClasses) {
        const newStates = [];
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            const stateName = ɵgetStoreMetadata(stateClass).name;
            if (NG_DEV_MODE) {
                ensureStateNameIsUnique(stateName, stateClass, statesMap);
            }
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[meta.name] = path;
        // TODO: versions after v3 - we plan to get rid of the `path` property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative to what was exposed in v3 because this is used by many plugins
        meta.path = path;
    }
    hasBeenMountedAndBootstrapped(name, path) {
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        // This checks whether a state has been already added to the global graph and
        // its lifecycle is in 'bootstrapped' state.
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateFactory, deps: [{ token: i0.Injector }, { token: i1.NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: i2.InternalActions }, { token: i3.InternalDispatchedActionResults }, { token: i4.StateContextFactory }, { token: ɵINITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateFactory }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: StateFactory, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Injector }, { type: i1.NgxsConfig }, { type: StateFactory, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i2.InternalActions }, { type: i3.InternalDispatchedActionResults }, { type: i4.StateContextFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ɵINITIAL_STATE_TOKEN]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxVQUFVLEVBQ1YsUUFBUSxFQUNSLFFBQVEsRUFDUixRQUFRLEVBQ1IsTUFBTSxFQUVOLFVBQVUsRUFDVixNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLFFBQVEsRUFDUixTQUFTLEVBR1QsaUJBQWlCLEVBRWpCLG9CQUFvQixFQUdyQixNQUFNLHVCQUF1QixDQUFDO0FBQy9CLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDcEYsT0FBTyxFQUNMLFFBQVEsRUFDUixJQUFJLEVBRUosRUFBRSxFQUNGLFVBQVUsRUFFVixPQUFPLEVBQ1AsWUFBWSxFQUNiLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUNMLFVBQVUsRUFDVixjQUFjLEVBQ2QsTUFBTSxFQUNOLEdBQUcsRUFDSCxRQUFRLEVBQ1IsV0FBVyxFQUNYLFNBQVMsRUFDVixNQUFNLGdCQUFnQixDQUFDO0FBRXhCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDeEMsT0FBTyxFQUNMLFVBQVUsRUFDVixrQkFBa0IsRUFFbEIsV0FBVyxFQUNYLFlBQVksRUFJWixlQUFlLEVBQ2hCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBK0IsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDakYsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDeEUs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QyxHQUFHLElBQUksQ0FBQztRQUNuQyxzR0FBc0c7UUFDdEcsNkVBQTZFO1FBQzdFLDZHQUE2RztRQUM3RyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRU8sNkJBQTZCLENBQUMsSUFBWSxFQUFFLElBQVk7UUFDOUQsTUFBTSxpQ0FBaUMsR0FDckMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDO1FBQ25ELDZFQUE2RTtRQUM3RSw0Q0FBNEM7UUFDNUMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLGlDQUFpQyxDQUFDO0lBQ3RFLENBQUM7aUlBelRVLFlBQVksOE9BaUJiLG9CQUFvQjtxSUFqQm5CLFlBQVk7OzJGQUFaLFlBQVk7a0JBRHhCLFVBQVU7OzBCQVdOLFFBQVE7OzBCQUNSLFFBQVE7OzBCQUtSLFFBQVE7OzBCQUNSLE1BQU07MkJBQUMsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSW5qZWN0YWJsZSxcbiAgSW5qZWN0b3IsXG4gIE9wdGlvbmFsLFxuICBTa2lwU2VsZixcbiAgSW5qZWN0LFxuICBPbkRlc3Ryb3ksXG4gIMm1aXNQcm9taXNlLFxuICBpbmplY3Rcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICDJtW1lbW9pemUsXG4gIMm1TUVUQV9LRVksXG4gIMm1UGxhaW5PYmplY3RPZixcbiAgybVNZXRhRGF0YU1vZGVsLFxuICDJtWdldFN0b3JlTWV0YWRhdGEsXG4gIMm1U3RhdGVDbGFzc0ludGVybmFsLFxuICDJtUlOSVRJQUxfU1RBVEVfVE9LRU4sXG4gIMm1U2hhcmVkU2VsZWN0b3JPcHRpb25zLFxuICDJtVJ1bnRpbWVTZWxlY3RvckNvbnRleHRcbn0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIGdldFZhbHVlLCBzZXRWYWx1ZSB9IGZyb20gJ0BuZ3hzL3N0b3JlL3BsdWdpbnMnO1xuaW1wb3J0IHtcbiAgZm9ya0pvaW4sXG4gIGZyb20sXG4gIE9ic2VydmFibGUsXG4gIG9mLFxuICB0aHJvd0Vycm9yLFxuICBTdWJzY3JpcHRpb24sXG4gIFN1YmplY3QsXG4gIGlzT2JzZXJ2YWJsZVxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGRlZmF1bHRJZkVtcHR5LFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHNoYXJlUmVwbGF5LFxuICB0YWtlVW50aWxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XG5pbXBvcnQge1xuICBidWlsZEdyYXBoLFxuICBmaW5kRnVsbFBhcmVudFBhdGgsXG4gIE1hcHBlZFN0b3JlLFxuICBuYW1lVG9TdGF0ZSxcbiAgybVQUk9QX0dFVFRFUixcbiAgU3RhdGVLZXlHcmFwaCxcbiAgU3RhdGVzQW5kRGVmYXVsdHMsXG4gIFN0YXRlc0J5TmFtZSxcbiAgdG9wb2xvZ2ljYWxTb3J0XG59IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xuaW1wb3J0IHsgQWN0aW9uQ29udGV4dCwgQWN0aW9uU3RhdHVzLCBJbnRlcm5hbEFjdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcbmltcG9ydCB7IGVuc3VyZVN0YXRlTmFtZUlzVW5pcXVlLCBlbnN1cmVTdGF0ZXNBcmVEZWNvcmF0ZWQgfSBmcm9tICcuLi91dGlscy9zdG9yZS12YWxpZGF0b3JzJztcbmltcG9ydCB7IGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGUgfSBmcm9tICcuLi9pdnkvaXZ5LWVuYWJsZWQtaW4tZGV2LW1vZGUnO1xuaW1wb3J0IHsgTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXIgfSBmcm9tICcuLi9kZXYtZmVhdHVyZXMvbmd4cy11bmhhbmRsZWQtYWN0aW9ucy1sb2dnZXInO1xuaW1wb3J0IHsgTmd4c1VuaGFuZGxlZEVycm9ySGFuZGxlciB9IGZyb20gJy4uL25neHMtdW5oYW5kbGVkLWVycm9yLWhhbmRsZXInO1xuaW1wb3J0IHsgYXNzaWduVW5oYW5kbGVkQ2FsbGJhY2sgfSBmcm9tICcuL3VuaGFuZGxlZC1yeGpzLWVycm9yLWNhbGxiYWNrJztcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlICE9PSAndW5kZWZpbmVkJyAmJiBuZ0Rldk1vZGU7XG5cbmZ1bmN0aW9uIGNsb25lRGVmYXVsdHMoZGVmYXVsdHM6IGFueSk6IGFueSB7XG4gIGxldCB2YWx1ZSA9IGRlZmF1bHRzID09PSB1bmRlZmluZWQgPyB7fSA6IGRlZmF1bHRzO1xuXG4gIGlmIChkZWZhdWx0cykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xuICAgICAgdmFsdWUgPSBkZWZhdWx0cy5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmF1bHRzID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsdWUgPSB7IC4uLmRlZmF1bHRzIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBgU3RhdGVGYWN0b3J5YCBjbGFzcyBhZGRzIHJvb3QgYW5kIGZlYXR1cmUgc3RhdGVzIHRvIHRoZSBncmFwaC5cbiAqIFRoaXMgZXh0cmFjdHMgc3RhdGUgbmFtZXMgZnJvbSBzdGF0ZSBjbGFzc2VzLCBjaGVja3MgaWYgdGhleSBhbHJlYWR5XG4gKiBleGlzdCBpbiB0aGUgZ2xvYmFsIGdyYXBoLCB0aHJvd3MgZXJyb3JzIGlmIHRoZWlyIG5hbWVzIGFyZSBpbnZhbGlkLCBldGMuXG4gKiBTZWUgaXRzIGNvbnN0cnVjdG9yLCBzdGF0ZSBmYWN0b3JpZXMgaW5qZWN0IHN0YXRlIGZhY3RvcmllcyB0aGF0IGFyZVxuICogcGFyZW50LWxldmVsIHByb3ZpZGVycy4gVGhpcyBpcyByZXF1aXJlZCB0byBnZXQgZmVhdHVyZSBzdGF0ZXMgZnJvbSB0aGVcbiAqIGluamVjdG9yIG9uIHRoZSBzYW1lIGxldmVsLlxuICpcbiAqIFRoZSBgTmd4c01vZHVsZS5mb3JGZWF0dXJlKC4uLilgIHJldHVybnMgYHByb3ZpZGVyczogW1N0YXRlRmFjdG9yeSwgLi4uc3RhdGVzXWAuXG4gKiBUaGUgYFN0YXRlRmFjdG9yeWAgaXMgaW5pdGlhbGl6ZWQgb24gdGhlIGZlYXR1cmUgbGV2ZWwgYW5kIGdvZXMgdGhyb3VnaCBgLi4uc3RhdGVzYFxuICogdG8gZ2V0IHRoZW0gZnJvbSB0aGUgaW5qZWN0b3IgdGhyb3VnaCBgaW5qZWN0b3IuZ2V0KHN0YXRlKWAuXG4gKiBAaWdub3JlXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3RvcnkgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9hY3Rpb25zU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9wcm9wR2V0dGVyID0gaW5qZWN0KMm1UFJPUF9HRVRURVIpO1xuXG4gIHByaXZhdGUgX25neHNVbmhhbmRsZWRFcnJvckhhbmRsZXI6IE5neHNVbmhhbmRsZWRFcnJvckhhbmRsZXIgPSBudWxsITtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQFNraXBTZWxmKClcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoybVJTklUSUFMX1NUQVRFX1RPS0VOKVxuICAgIHByaXZhdGUgX2luaXRpYWxTdGF0ZTogYW55XG4gICkge31cblxuICBwcml2YXRlIF9zdGF0ZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcblxuICBnZXQgc3RhdGVzKCk6IE1hcHBlZFN0b3JlW10ge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXMgOiB0aGlzLl9zdGF0ZXM7XG4gIH1cblxuICBwcml2YXRlIF9zdGF0ZXNCeU5hbWU6IFN0YXRlc0J5TmFtZSA9IHt9O1xuXG4gIGdldCBzdGF0ZXNCeU5hbWUoKTogU3RhdGVzQnlOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzQnlOYW1lIDogdGhpcy5fc3RhdGVzQnlOYW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3RhdGVQYXRoczogybVQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fTtcblxuICBwcml2YXRlIGdldCBzdGF0ZVBhdGhzKCk6IMm1UGxhaW5PYmplY3RPZjxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVQYXRocyA6IHRoaXMuX3N0YXRlUGF0aHM7XG4gIH1cblxuICBnZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gybVtZW1vaXplKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBjb25zdCBzdGF0ZUZhY3RvcnkgPSB0aGlzO1xuICAgIGNvbnN0IHByb3BHZXR0ZXIgPSBzdGF0ZUZhY3RvcnkuX3Byb3BHZXR0ZXI7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICBjb25zdCBwYXRoID0gc3RhdGVGYWN0b3J5LnN0YXRlUGF0aHNba2V5XTtcbiAgICAgIHJldHVybiBwYXRoID8gcHJvcEdldHRlcihwYXRoLnNwbGl0KCcuJykpIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0OiDJtVJ1bnRpbWVTZWxlY3RvckNvbnRleHQgPSB0aGlzLl9wYXJlbnRGYWN0b3J5XG4gICAgICA/IHRoaXMuX3BhcmVudEZhY3RvcnkuZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCgpXG4gICAgICA6IHtcbiAgICAgICAgICBnZXRTdGF0ZUdldHRlcihrZXk6IHN0cmluZykge1xuICAgICAgICAgICAgLy8gVXNlIGBAX19JTkxJTkVfX2AgYW5ub3RhdGlvbiB0byBmb3JjZWx5IGlubGluZSBgcmVzb2x2ZUdldHRlcmAuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgVGVyc2VyIGFubm90YXRpb24sIHdoaWNoIHdpbGwgZnVuY3Rpb24gb25seSBpbiB0aGUgcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgICAgICAgbGV0IGdldHRlciA9IC8qQF9fSU5MSU5FX18qLyByZXNvbHZlR2V0dGVyKGtleSk7XG4gICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgLy8gTGF0ZSBsb2FkZWQgZ2V0dGVyXG4gICAgICAgICAgICAgIGlmICghZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gLypAX19JTkxJTkVfXyovIHJlc29sdmVHZXR0ZXIoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyKC4uLmFyZ3MpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFNlbGVjdG9yT3B0aW9ucyhsb2NhbE9wdGlvbnM/OiDJtVNoYXJlZFNlbGVjdG9yT3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsU2VsZWN0b3JPcHRpb25zID0gc3RhdGVGYWN0b3J5Ll9jb25maWcuc2VsZWN0b3JPcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZ2xvYmFsU2VsZWN0b3JPcHRpb25zLFxuICAgICAgICAgICAgICAuLi4obG9jYWxPcHRpb25zIHx8IHt9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0pO1xuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cbiAgICovXG4gIGFkZChzdGF0ZUNsYXNzZXM6IMm1U3RhdGVDbGFzc0ludGVybmFsW10pOiBNYXBwZWRTdG9yZVtdIHtcbiAgICBpZiAoTkdfREVWX01PREUpIHtcbiAgICAgIGVuc3VyZVN0YXRlc0FyZURlY29yYXRlZChzdGF0ZUNsYXNzZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbmV3U3RhdGVzIH0gPSB0aGlzLmFkZFRvU3RhdGVzTWFwKHN0YXRlQ2xhc3Nlcyk7XG4gICAgaWYgKCFuZXdTdGF0ZXMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICBjb25zdCBzdGF0ZUdyYXBoOiBTdGF0ZUtleUdyYXBoID0gYnVpbGRHcmFwaChuZXdTdGF0ZXMpO1xuICAgIGNvbnN0IHNvcnRlZFN0YXRlczogc3RyaW5nW10gPSB0b3BvbG9naWNhbFNvcnQoc3RhdGVHcmFwaCk7XG4gICAgY29uc3QgcGF0aHM6IMm1UGxhaW5PYmplY3RPZjxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xuICAgIGNvbnN0IG5hbWVHcmFwaDogybVQbGFpbk9iamVjdE9mPMm1U3RhdGVDbGFzc0ludGVybmFsPiA9IG5hbWVUb1N0YXRlKG5ld1N0YXRlcyk7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XG4gICAgICBjb25zdCBzdGF0ZUNsYXNzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbCA9IG5hbWVHcmFwaFtuYW1lXTtcbiAgICAgIGNvbnN0IHBhdGg6IHN0cmluZyA9IHBhdGhzW25hbWVdO1xuICAgICAgY29uc3QgbWV0YTogybVNZXRhRGF0YU1vZGVsID0gc3RhdGVDbGFzc1vJtU1FVEFfS0VZXSE7XG5cbiAgICAgIHRoaXMuYWRkUnVudGltZUluZm9Ub01ldGEobWV0YSwgcGF0aCk7XG5cbiAgICAgIC8vIE5vdGU6IHByZXZpb3VzbHkgd2UgY2FsbGVkIGBlbnN1cmVTdGF0ZUNsYXNzSXNJbmplY3RhYmxlYCB3aXRoaW4gdGhlXG4gICAgICAvLyBgU3RhdGVgIGRlY29yYXRvci4gVGhpcyBjaGVjayBpcyBtb3ZlZCBoZXJlIGJlY2F1c2UgdGhlIGDJtXByb3ZgIHByb3BlcnR5XG4gICAgICAvLyB3aWxsIG5vdCBleGlzdCBvbiB0aGUgY2xhc3MgaW4gSklUIG1vZGUgKGJlY2F1c2UgaXQncyBzZXQgYXN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24gdGhyb3VnaCBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCkuXG4gICAgICBpZiAoTkdfREVWX01PREUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZShzdGF0ZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdGVNYXA6IE1hcHBlZFN0b3JlID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBpc0luaXRpYWxpc2VkOiBmYWxzZSxcbiAgICAgICAgYWN0aW9uczogbWV0YS5hY3Rpb25zLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxuICAgICAgICBkZWZhdWx0czogY2xvbmVEZWZhdWx0cyhtZXRhLmRlZmF1bHRzKVxuICAgICAgfTtcblxuICAgICAgLy8gZW5zdXJlIG91ciBzdG9yZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkXG4gICAgICAvLyBidXQgZG9uJ3QgdGhyb3cgc2luY2UgaXQgY291bGQgYmUgbGF6eVxuICAgICAgLy8gbG9hZGVkIGZyb20gZGlmZmVyZW50IHBhdGhzXG4gICAgICBpZiAoIXRoaXMuaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZSwgcGF0aCkpIHtcbiAgICAgICAgYm9vdHN0cmFwcGVkU3RvcmVzLnB1c2goc3RhdGVNYXApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlTWFwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm9vdHN0cmFwcGVkU3RvcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNldCBvZiBzdGF0ZXMgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gdGhlIGRlZmF1bHRzXG4gICAqL1xuICBhZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZUNsYXNzZXM6IMm1U3RhdGVDbGFzc0ludGVybmFsW10pOiBTdGF0ZXNBbmREZWZhdWx0cyB7XG4gICAgY29uc3QgY2xhc3NlczogybVTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IHN0YXRlQ2xhc3NlcyB8fCBbXTtcblxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IHRoaXMuYWRkKGNsYXNzZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gbWFwcGVkU3RvcmVzLnJlZHVjZShcbiAgICAgIChyZXN1bHQ6IGFueSwgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKSA9PlxuICAgICAgICBzZXRWYWx1ZShyZXN1bHQsIG1hcHBlZFN0b3JlLnBhdGgsIG1hcHBlZFN0b3JlLmRlZmF1bHRzKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzOiBtYXBwZWRTdG9yZXMgfTtcbiAgfVxuXG4gIGNvbm5lY3RBY3Rpb25IYW5kbGVycygpOiB2b2lkIHtcbiAgICAvLyBOb3RlOiBXZSBoYXZlIHRvIGNvbm5lY3QgYWN0aW9ucyBvbmx5IG9uY2Ugd2hlbiB0aGUgYFN0YXRlRmFjdG9yeWBcbiAgICAvLyAgICAgICBpcyBiZWluZyBjcmVhdGVkIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBjaGVja3MgaWYgd2UncmUgaW5cbiAgICAvLyAgICAgICBhIGNoaWxkIHN0YXRlIGZhY3RvcnkgYW5kIHRoZSBwYXJlbnQgc3RhdGUgZmFjdG9yeSBhbHJlYWR5IGV4aXN0cy5cbiAgICBpZiAodGhpcy5fcGFyZW50RmFjdG9yeSB8fCB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzcGF0Y2hlZCQgPSBuZXcgU3ViamVjdDxBY3Rpb25Db250ZXh0PigpO1xuICAgIHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLl9hY3Rpb25zXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcbiAgICAgICAgbWVyZ2VNYXAoY3R4ID0+IHtcbiAgICAgICAgICBkaXNwYXRjaGVkJC5uZXh0KGN0eCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9uOiBhbnkgPSBjdHguYWN0aW9uO1xuICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZUFjdGlvbnMoZGlzcGF0Y2hlZCQsIGFjdGlvbiEpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgbmd4c1VuaGFuZGxlZEVycm9ySGFuZGxlciA9ICh0aGlzLl9uZ3hzVW5oYW5kbGVkRXJyb3JIYW5kbGVyIHx8PVxuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdG9yLmdldChOZ3hzVW5oYW5kbGVkRXJyb3JIYW5kbGVyKSk7XG4gICAgICAgICAgICAgIGNvbnN0IGhhbmRsZWFibGVFcnJvciA9IGFzc2lnblVuaGFuZGxlZENhbGxiYWNrKGVycm9yLCAoKSA9PlxuICAgICAgICAgICAgICAgIG5neHNVbmhhbmRsZWRFcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgYWN0aW9uIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBvZig8QWN0aW9uQ29udGV4dD57XG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGhhbmRsZWFibGVFcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgYWN0aW9ucyBvbiB0aGUgc3RhdGVzLlxuICAgKi9cbiAgaW52b2tlQWN0aW9ucyhkaXNwYXRjaGVkJDogT2JzZXJ2YWJsZTxBY3Rpb25Db250ZXh0PiwgYWN0aW9uOiBhbnkpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pITtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGRpc3BhdGNoZWQgYWN0aW9uIGhhcyBiZWVuIGhhbmRsZWQsIHRoaXMgaXMgYXNzaWduZWRcbiAgICAvLyB0byBgdHJ1ZWAgd2l0aGluIHRoZSBiZWxvdyBgZm9yYCBsb29wIGlmIGFueSBgYWN0aW9uTWV0YXNgIGhhcyBiZWVuIGZvdW5kLlxuICAgIGxldCBhY3Rpb25IYXNCZWVuSGFuZGxlZCA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xuXG4gICAgICBpZiAoYWN0aW9uTWV0YXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBgaXNQcm9taXNlYCBpbnN0ZWFkIG9mIGNoZWNraW5nIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIGByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlYC4gSW4gem9uZS5qcyBwYXRjaGVkIGVudmlyb25tZW50cywgYGdsb2JhbC5Qcm9taXNlYFxuICAgICAgICAgICAgLy8gaXMgdGhlIGBab25lQXdhcmVQcm9taXNlYC4gU29tZSBBUElzLCB3aGljaCBhcmUgbGlrZWx5IG5vdCBwYXRjaGVkIGJ5IHpvbmUuanNcbiAgICAgICAgICAgIC8vIGZvciBjZXJ0YWluIHJlYXNvbnMsIG1pZ2h0IG5vdCB3b3JrIHdpdGggYGluc3RhbmNlb2ZgLiBGb3IgaW5zdGFuY2UsIHRoZSBkeW5hbWljXG4gICAgICAgICAgICAvLyBpbXBvcnQgcmV0dXJucyBhIG5hdGl2ZSBwcm9taXNlIChub3QgYSBgWm9uZUF3YXJlUHJvbWlzZWApLCBjYXVzaW5nIHRoaXMgY2hlY2sgdG9cbiAgICAgICAgICAgIC8vIGJlIGZhbHN5LlxuICAgICAgICAgICAgaWYgKMm1aXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBvYnNlcnZhYmxlIGhhcyBiZWVuIGNvbXBsZXRlZCB3L28gZW1pdHRpbmdcbiAgICAgICAgICAgICAgLy8gYW55IHZhbHVlIHRoZW4gd2Ugd291bGRuJ3Qgd2FudCB0byBjb21wbGV0ZSB0aGUgd2hvbGUgY2hhaW5cbiAgICAgICAgICAgICAgLy8gb2YgYWN0aW9ucy4gU2luY2UgaWYgYW55IG9ic2VydmFibGUgY29tcGxldGVzIHRoZW5cbiAgICAgICAgICAgICAgLy8gYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICAgICAgICAgIC8vIEZvciBpbnN0YW5jZSBpZiBhbnkgYWN0aW9uIGhhbmRsZXIgd291bGQndmUgaGFkIHN1Y2ggc3RhdGVtZW50OlxuICAgICAgICAgICAgICAvLyBgaGFuZGxlcihjdHgpIHsgcmV0dXJuIEVNUFRZOyB9YFxuICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3hzL3N0b3JlL2lzc3Vlcy8xNTY4XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxuICAgICAgICAgICAgICAgIG1lcmdlTWFwKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoybVpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpc09ic2VydmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoe30pXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG86IG9mQWN0aW9uRGlzcGF0Y2hlZCBzaG91bGQgYmUgdXNlZCB3aXRoIGFjdGlvbiBjbGFzc1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxuICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKGRpc3BhdGNoZWQkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbiBhcyBhbnkpKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFjdGlvbkhhc0JlZW5IYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBgTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXJgIGlzIGEgdHJlZS1zaGFrYWJsZSBjbGFzcyB3aGljaCBmdW5jdGlvbnNcbiAgICAvLyBvbmx5IGR1cmluZyBkZXZlbG9wbWVudC5cbiAgICBpZiAoTkdfREVWX01PREUgJiYgIWFjdGlvbkhhc0JlZW5IYW5kbGVkKSB7XG4gICAgICBjb25zdCB1bmhhbmRsZWRBY3Rpb25zTG9nZ2VyID0gdGhpcy5faW5qZWN0b3IuZ2V0KE5neHNVbmhhbmRsZWRBY3Rpb25zTG9nZ2VyLCBudWxsKTtcbiAgICAgIC8vIFRoZSBgTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXJgIHdpbGwgbm90IGJlIHJlc29sdmVkIGJ5IHRoZSBpbmplY3RvciBpZiB0aGVcbiAgICAgIC8vIGBOZ3hzRGV2ZWxvcG1lbnRNb2R1bGVgIGlzIG5vdCBwcm92aWRlZC4gSXQncyBlbm91Z2ggdG8gY2hlY2sgd2hldGhlciB0aGUgYGluamVjdG9yLmdldGBcbiAgICAgIC8vIGRpZG4ndCByZXR1cm4gYG51bGxgIHNvIHdlIG1heSBlbnN1cmUgdGhlIG1vZHVsZSBoYXMgYmVlbiBpbXBvcnRlZC5cbiAgICAgIGlmICh1bmhhbmRsZWRBY3Rpb25zTG9nZ2VyKSB7XG4gICAgICAgIHVuaGFuZGxlZEFjdGlvbnNMb2dnZXIud2FybihhY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkVG9TdGF0ZXNNYXAoc3RhdGVDbGFzc2VzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbFtdKToge1xuICAgIG5ld1N0YXRlczogybVTdGF0ZUNsYXNzSW50ZXJuYWxbXTtcbiAgfSB7XG4gICAgY29uc3QgbmV3U3RhdGVzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbFtdID0gW107XG4gICAgY29uc3Qgc3RhdGVzTWFwOiBTdGF0ZXNCeU5hbWUgPSB0aGlzLnN0YXRlc0J5TmFtZTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGVDbGFzcyBvZiBzdGF0ZUNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IHN0YXRlTmFtZSA9IMm1Z2V0U3RvcmVNZXRhZGF0YShzdGF0ZUNsYXNzKS5uYW1lITtcbiAgICAgIGlmIChOR19ERVZfTU9ERSkge1xuICAgICAgICBlbnN1cmVTdGF0ZU5hbWVJc1VuaXF1ZShzdGF0ZU5hbWUsIHN0YXRlQ2xhc3MsIHN0YXRlc01hcCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1bm1vdW50ZWRTdGF0ZSA9ICFzdGF0ZXNNYXBbc3RhdGVOYW1lXTtcbiAgICAgIGlmICh1bm1vdW50ZWRTdGF0ZSkge1xuICAgICAgICBuZXdTdGF0ZXMucHVzaChzdGF0ZUNsYXNzKTtcbiAgICAgICAgc3RhdGVzTWFwW3N0YXRlTmFtZV0gPSBzdGF0ZUNsYXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IG5ld1N0YXRlcyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhOiDJtU1ldGFEYXRhTW9kZWwsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGVQYXRoc1ttZXRhLm5hbWUhXSA9IHBhdGg7XG4gICAgLy8gVE9ETzogdmVyc2lvbnMgYWZ0ZXIgdjMgLSB3ZSBwbGFuIHRvIGdldCByaWQgb2YgdGhlIGBwYXRoYCBwcm9wZXJ0eSBiZWNhdXNlIGl0IGlzIG5vbi1kZXRlcm1pbmlzdGljXG4gICAgLy8gd2UgY2FuIGRvIHRoaXMgd2hlbiB3ZSBnZXQgcmlkIG9mIHRoZSBpbmNvcnJlY3RseSBleHBvc2VkIGdldFN0b3JlTWV0YWRhdGFcbiAgICAvLyBXZSB3aWxsIG5lZWQgdG8gY29tZSB1cCB3aXRoIGFuIGFsdGVybmF0aXZlIHRvIHdoYXQgd2FzIGV4cG9zZWQgaW4gdjMgYmVjYXVzZSB0aGlzIGlzIHVzZWQgYnkgbWFueSBwbHVnaW5zXG4gICAgbWV0YS5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIHByaXZhdGUgaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU6IGJvb2xlYW4gPVxuICAgICAgZ2V0VmFsdWUodGhpcy5faW5pdGlhbFN0YXRlLCBwYXRoKSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIFRoaXMgY2hlY2tzIHdoZXRoZXIgYSBzdGF0ZSBoYXMgYmVlbiBhbHJlYWR5IGFkZGVkIHRvIHRoZSBnbG9iYWwgZ3JhcGggYW5kXG4gICAgLy8gaXRzIGxpZmVjeWNsZSBpcyBpbiAnYm9vdHN0cmFwcGVkJyBzdGF0ZS5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlO1xuICB9XG59XG4iXX0=