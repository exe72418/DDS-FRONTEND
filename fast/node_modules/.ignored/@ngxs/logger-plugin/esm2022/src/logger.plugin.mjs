import { Inject, Injectable, Injector } from '@angular/core';
import { Store } from '@ngxs/store';
import { catchError, tap } from 'rxjs/operators';
import { ActionLogger } from './action-logger';
import { LogWriter } from './log-writer';
import { NGXS_LOGGER_PLUGIN_OPTIONS } from './symbols';
import * as i0 from "@angular/core";
export class NgxsLoggerPlugin {
    constructor(_options, _injector) {
        this._options = _options;
        this._injector = _injector;
    }
    handle(state, event, next) {
        if (this._options.disabled || !this._options.filter(event, state)) {
            return next(state, event);
        }
        this._logWriter = this._logWriter || new LogWriter(this._options);
        // Retrieve lazily to avoid cyclic dependency exception
        this._store = this._store || this._injector.get(Store);
        const actionLogger = new ActionLogger(event, this._store, this._logWriter);
        actionLogger.dispatched(state);
        return next(state, event).pipe(tap(nextState => {
            actionLogger.completed(nextState);
        }), catchError(error => {
            actionLogger.errored(error);
            throw error;
        }));
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: NgxsLoggerPlugin, deps: [{ token: NGXS_LOGGER_PLUGIN_OPTIONS }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: NgxsLoggerPlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: NgxsLoggerPlugin, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [NGXS_LOGGER_PLUGIN_OPTIONS]
                }] }, { type: i0.Injector }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2VyLnBsdWdpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL2xvZ2dlci1wbHVnaW4vc3JjL2xvZ2dlci5wbHVnaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFcEMsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVqRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBQTJCLDBCQUEwQixFQUFFLE1BQU0sV0FBVyxDQUFDOztBQUdoRixNQUFNLE9BQU8sZ0JBQWdCO0lBSTNCLFlBQzhDLFFBQWlDLEVBQ3JFLFNBQW1CO1FBRGlCLGFBQVEsR0FBUixRQUFRLENBQXlCO1FBQ3JFLGNBQVMsR0FBVCxTQUFTLENBQVU7SUFDMUIsQ0FBQztJQUVKLE1BQU0sQ0FBQyxLQUFVLEVBQUUsS0FBVSxFQUFFLElBQXNCO1FBQ25ELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNuRSxPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUVELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBUSxLQUFLLENBQUMsQ0FBQztRQUU5RCxNQUFNLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFM0UsWUFBWSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUvQixPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUM1QixHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDZCxZQUFZLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BDLENBQUMsQ0FBQyxFQUNGLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixZQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVCLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7aUlBL0JVLGdCQUFnQixrQkFLakIsMEJBQTBCO3FJQUx6QixnQkFBZ0I7OzJGQUFoQixnQkFBZ0I7a0JBRDVCLFVBQVU7OzBCQU1OLE1BQU07MkJBQUMsMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmd4cy9zdG9yZSc7XG5pbXBvcnQgeyBOZ3hzTmV4dFBsdWdpbkZuLCBOZ3hzUGx1Z2luIH0gZnJvbSAnQG5neHMvc3RvcmUvcGx1Z2lucyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IEFjdGlvbkxvZ2dlciB9IGZyb20gJy4vYWN0aW9uLWxvZ2dlcic7XG5pbXBvcnQgeyBMb2dXcml0ZXIgfSBmcm9tICcuL2xvZy13cml0ZXInO1xuaW1wb3J0IHsgTmd4c0xvZ2dlclBsdWdpbk9wdGlvbnMsIE5HWFNfTE9HR0VSX1BMVUdJTl9PUFRJT05TIH0gZnJvbSAnLi9zeW1ib2xzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5neHNMb2dnZXJQbHVnaW4gaW1wbGVtZW50cyBOZ3hzUGx1Z2luIHtcbiAgcHJpdmF0ZSBfc3RvcmU6IFN0b3JlO1xuICBwcml2YXRlIF9sb2dXcml0ZXI6IExvZ1dyaXRlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KE5HWFNfTE9HR0VSX1BMVUdJTl9PUFRJT05TKSBwcml2YXRlIF9vcHRpb25zOiBOZ3hzTG9nZ2VyUGx1Z2luT3B0aW9ucyxcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3JcbiAgKSB7fVxuXG4gIGhhbmRsZShzdGF0ZTogYW55LCBldmVudDogYW55LCBuZXh0OiBOZ3hzTmV4dFBsdWdpbkZuKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQgfHwgIXRoaXMuX29wdGlvbnMuZmlsdGVyIShldmVudCwgc3RhdGUpKSB7XG4gICAgICByZXR1cm4gbmV4dChzdGF0ZSwgZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2xvZ1dyaXRlciA9IHRoaXMuX2xvZ1dyaXRlciB8fCBuZXcgTG9nV3JpdGVyKHRoaXMuX29wdGlvbnMpO1xuICAgIC8vIFJldHJpZXZlIGxhemlseSB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBleGNlcHRpb25cbiAgICB0aGlzLl9zdG9yZSA9IHRoaXMuX3N0b3JlIHx8IHRoaXMuX2luamVjdG9yLmdldDxTdG9yZT4oU3RvcmUpO1xuXG4gICAgY29uc3QgYWN0aW9uTG9nZ2VyID0gbmV3IEFjdGlvbkxvZ2dlcihldmVudCwgdGhpcy5fc3RvcmUsIHRoaXMuX2xvZ1dyaXRlcik7XG5cbiAgICBhY3Rpb25Mb2dnZXIuZGlzcGF0Y2hlZChzdGF0ZSk7XG5cbiAgICByZXR1cm4gbmV4dChzdGF0ZSwgZXZlbnQpLnBpcGUoXG4gICAgICB0YXAobmV4dFN0YXRlID0+IHtcbiAgICAgICAgYWN0aW9uTG9nZ2VyLmNvbXBsZXRlZChuZXh0U3RhdGUpO1xuICAgICAgfSksXG4gICAgICBjYXRjaEVycm9yKGVycm9yID0+IHtcbiAgICAgICAgYWN0aW9uTG9nZ2VyLmVycm9yZWQoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIl19