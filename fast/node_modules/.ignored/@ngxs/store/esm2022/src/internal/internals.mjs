import { InjectionToken, inject } from '@angular/core';
import { ɵMETA_KEY } from '@ngxs/store/internals';
import { NgxsConfig } from '../symbols';
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 */
function compliantPropGetter(paths) {
    return obj => {
        for (let i = 0; i < paths.length; i++) {
            if (!obj)
                return undefined;
            obj = obj[paths[i]];
        }
        return obj;
    };
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 */
function fastPropGetter(paths) {
    const segments = paths;
    let seg = 'store.' + segments[0];
    let i = 0;
    const l = segments.length;
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    const fn = new Function('store', 'return ' + expr + ';');
    return fn;
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 *
 * Marked for removal. It's only used within `createSelectorFn`.
 */
export function propGetter(paths, config) {
    if (config?.compatibility?.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
// This injection token selects the prop getter implementation once the app is
// bootstrapped, as the `propGetter` function's behavior determines the implementation
// each time it's called. It accepts the config as the second argument. We no longer
// need to check for the `strictContentSecurityPolicy` every time the prop getter
// implementation is selected. Now, the `propGetter` function is only used within
// `createSelectorFn`, which, in turn, is solely used by the `Select` decorator.
// We've been trying to deprecate the `Select` decorator because it's unstable with
// server-side rendering and micro-frontend applications.
export const ɵPROP_GETTER = new InjectionToken(NG_DEV_MODE ? 'PROP_GETTER' : '', {
    providedIn: 'root',
    factory: () => inject(NgxsConfig).compatibility?.strictContentSecurityPolicy
        ? compliantPropGetter
        : fastPropGetter
});
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 */
export function buildGraph(stateClasses) {
    const findName = (stateClass) => {
        const meta = stateClasses.find(g => g === stateClass);
        if (NG_DEV_MODE && !meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return meta[ɵMETA_KEY].name;
    };
    return stateClasses.reduce((result, stateClass) => {
        const { name, children } = stateClass[ɵMETA_KEY];
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 */
export function nameToState(states) {
    return states.reduce((result, stateClass) => {
        const meta = stateClass[ɵMETA_KEY];
        result[meta.name] = stateClass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 */
export function findFullParentPath(obj, newObj = {}) {
    const visit = (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    };
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 */
export function topologicalSort(graph) {
    const sorted = [];
    const visited = {};
    const visit = (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((dep) => {
            if (NG_DEV_MODE && ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(k => visit(k));
    return sorted.reverse();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvc3RvcmUvc3JjL2ludGVybmFsL2ludGVybmFscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUd2RCxPQUFPLEVBQ0wsU0FBUyxFQUlWLE1BQU0sdUJBQXVCLENBQUM7QUFFL0IsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUl4QyxNQUFNLFdBQVcsR0FBRyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO0FBMkJsRTs7Ozs7Ozs7O0dBU0c7QUFDSCxTQUFTLG1CQUFtQixDQUFDLEtBQWU7SUFDMUMsT0FBTyxHQUFHLENBQUMsRUFBRTtRQUNYLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDdEMsSUFBSSxDQUFDLEdBQUc7Z0JBQUUsT0FBTyxTQUFTLENBQUM7WUFDM0IsR0FBRyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxjQUFjLENBQUMsS0FBZTtJQUNyQyxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUM7SUFDdkIsSUFBSSxHQUFHLEdBQUcsUUFBUSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO0lBRTFCLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQztJQUNmLE9BQU8sRUFBRSxDQUFDLEdBQUcs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QUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUM5QixTQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLENBQUM7UUFFRCxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7UUFFckIsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQVcsRUFBRSxFQUFFO1lBQ2xDLElBQUksV0FBVyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQy9DLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0JBQXdCLEdBQUcscUJBQXFCLElBQUksTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQ25GLENBQUM7WUFDSixDQUFDO1lBRUQsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDakIsT0FBTztZQUNULENBQUM7WUFFRCxLQUFLLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BCLENBQUM7SUFDSCxDQUFDLENBQUM7SUFFRixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTFDLE9BQU8sTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzFCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgaW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7XG4gIMm1TUVUQV9LRVksXG4gIMm1UGxhaW5PYmplY3RPZixcbiAgybVTdGF0ZUNsYXNzSW50ZXJuYWwsXG4gIMm1QWN0aW9uSGFuZGxlck1ldGFEYXRhXG59IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5cbmltcG9ydCB7IE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcblxuZGVjbGFyZSBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XG5cbmNvbnN0IE5HX0RFVl9NT0RFID0gdHlwZW9mIG5nRGV2TW9kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbmdEZXZNb2RlO1xuXG5leHBvcnQgdHlwZSBTdGF0ZUtleUdyYXBoID0gybVQbGFpbk9iamVjdE9mPHN0cmluZ1tdPjtcbmV4cG9ydCB0eXBlIFN0YXRlc0J5TmFtZSA9IMm1UGxhaW5PYmplY3RPZjzJtVN0YXRlQ2xhc3NJbnRlcm5hbD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVPcGVyYXRpb25zPFQ+IHtcbiAgZ2V0U3RhdGUoKTogVDtcblxuICBzZXRTdGF0ZSh2YWw6IFQpOiB2b2lkO1xuXG4gIGRpc3BhdGNoKGFjdGlvbk9yQWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcHBlZFN0b3JlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBpc0luaXRpYWxpc2VkOiBib29sZWFuO1xuICBhY3Rpb25zOiDJtVBsYWluT2JqZWN0T2Y8ybVBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XG4gIGRlZmF1bHRzOiBhbnk7XG4gIGluc3RhbmNlOiBhbnk7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZXNBbmREZWZhdWx0cyB7XG4gIGRlZmF1bHRzOiBhbnk7XG4gIHN0YXRlczogTWFwcGVkU3RvcmVbXTtcbn1cblxuLyoqXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxuICpcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxuICpcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGFzIGZhc3QgYXMgdGhlIGBmYXN0UHJvcEdldHRlcmAgYnV0IGlzIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBjb21wbGlhbnQuXG4gKiBTZWUgcGVyZiBoaXQ6IGh0dHBzOi8vanNwZXJmLmNvbS9mYXN0LXZhbHVlLWdldHRlci1naXZlbi1wYXRoLzFcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcbiAgcmV0dXJuIG9iaiA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICBvYmogPSBvYmpbcGF0aHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW46XG4gKiAtIHBsdWNrIChPYnNlcnZhYmxlIG9wZXJhdG9yKVxuICogLSBtZW1vaXplXG4gKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBmYXN0UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGhzO1xuICBsZXQgc2VnID0gJ3N0b3JlLicgKyBzZWdtZW50c1swXTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gIGxldCBleHByID0gc2VnO1xuICB3aGlsZSAoKytpIDwgbCkge1xuICAgIGV4cHIgPSBleHByICsgJyAmJiAnICsgKHNlZyA9IHNlZyArICcuJyArIHNlZ21lbnRzW2ldKTtcbiAgfVxuXG4gIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzdG9yZScsICdyZXR1cm4gJyArIGV4cHIgKyAnOycpO1xuXG4gIHJldHVybiA8KHg6IGFueSkgPT4gYW55PmZuO1xufVxuXG4vKipcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XG4gKlxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXG4gKlxuICogQGlnbm9yZVxuICpcbiAqIE1hcmtlZCBmb3IgcmVtb3ZhbC4gSXQncyBvbmx5IHVzZWQgd2l0aGluIGBjcmVhdGVTZWxlY3RvckZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdLCBjb25maWc6IE5neHNDb25maWcpIHtcbiAgaWYgKGNvbmZpZz8uY29tcGF0aWJpbGl0eT8uc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5KSB7XG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYXN0UHJvcEdldHRlcihwYXRocyk7XG4gIH1cbn1cblxuLy8gVGhpcyBpbmplY3Rpb24gdG9rZW4gc2VsZWN0cyB0aGUgcHJvcCBnZXR0ZXIgaW1wbGVtZW50YXRpb24gb25jZSB0aGUgYXBwIGlzXG4vLyBib290c3RyYXBwZWQsIGFzIHRoZSBgcHJvcEdldHRlcmAgZnVuY3Rpb24ncyBiZWhhdmlvciBkZXRlcm1pbmVzIHRoZSBpbXBsZW1lbnRhdGlvblxuLy8gZWFjaCB0aW1lIGl0J3MgY2FsbGVkLiBJdCBhY2NlcHRzIHRoZSBjb25maWcgYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gV2Ugbm8gbG9uZ2VyXG4vLyBuZWVkIHRvIGNoZWNrIGZvciB0aGUgYHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeWAgZXZlcnkgdGltZSB0aGUgcHJvcCBnZXR0ZXJcbi8vIGltcGxlbWVudGF0aW9uIGlzIHNlbGVjdGVkLiBOb3csIHRoZSBgcHJvcEdldHRlcmAgZnVuY3Rpb24gaXMgb25seSB1c2VkIHdpdGhpblxuLy8gYGNyZWF0ZVNlbGVjdG9yRm5gLCB3aGljaCwgaW4gdHVybiwgaXMgc29sZWx5IHVzZWQgYnkgdGhlIGBTZWxlY3RgIGRlY29yYXRvci5cbi8vIFdlJ3ZlIGJlZW4gdHJ5aW5nIHRvIGRlcHJlY2F0ZSB0aGUgYFNlbGVjdGAgZGVjb3JhdG9yIGJlY2F1c2UgaXQncyB1bnN0YWJsZSB3aXRoXG4vLyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgYW5kIG1pY3JvLWZyb250ZW5kIGFwcGxpY2F0aW9ucy5cbmV4cG9ydCBjb25zdCDJtVBST1BfR0VUVEVSID0gbmV3IEluamVjdGlvblRva2VuPChwYXRoczogc3RyaW5nW10pID0+ICh4OiBhbnkpID0+IGFueT4oXG4gIE5HX0RFVl9NT0RFID8gJ1BST1BfR0VUVEVSJyA6ICcnLFxuICB7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAgIGZhY3Rvcnk6ICgpID0+XG4gICAgICBpbmplY3QoTmd4c0NvbmZpZykuY29tcGF0aWJpbGl0eT8uc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5XG4gICAgICAgID8gY29tcGxpYW50UHJvcEdldHRlclxuICAgICAgICA6IGZhc3RQcm9wR2V0dGVyXG4gIH1cbik7XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RhdGVzLCBpdCB3aWxsIHJldHVybiBhIG9iamVjdCBncmFwaC4gRXhhbXBsZTpcbiAqICAgIGNvbnN0IHN0YXRlcyA9IFtcbiAqICAgICAgQ2FydCxcbiAqICAgICAgQ2FydFNhdmVkLFxuICogICAgICBDYXJ0U2F2ZWRJdGVtc1xuICogICAgXVxuICpcbiAqIHdvdWxkIHJldHVybjpcbiAqXG4gKiAgY29uc3QgZ3JhcGggPSB7XG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxuICogICAgaXRlbXM6IFtdXG4gKiAgfTtcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdyYXBoKHN0YXRlQ2xhc3NlczogybVTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlS2V5R3JhcGgge1xuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbCkgPT4ge1xuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzZXMuZmluZChnID0+IGcgPT09IHN0YXRlQ2xhc3MpO1xuXG4gICAgaWYgKE5HX0RFVl9NT0RFICYmICFtZXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDaGlsZCBzdGF0ZSBub3QgZm91bmQ6ICR7c3RhdGVDbGFzc30uIFxcclxcbllvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gYWRkIHN0YXRlcyB0byBtb2R1bGVgXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhIVvJtU1FVEFfS0VZXSEubmFtZSE7XG4gIH07XG5cbiAgcmV0dXJuIHN0YXRlQ2xhc3Nlcy5yZWR1Y2U8U3RhdGVLZXlHcmFwaD4oXG4gICAgKHJlc3VsdDogU3RhdGVLZXlHcmFwaCwgc3RhdGVDbGFzczogybVTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgY2hpbGRyZW4gfSA9IHN0YXRlQ2xhc3NbybVNRVRBX0tFWV0hO1xuICAgICAgcmVzdWx0W25hbWUhXSA9IChjaGlsZHJlbiB8fCBbXSkubWFwKGZpbmROYW1lKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxuICogcmV0dXJuaW5nIHRoZSBuYW1lIGFuZCBzdGF0ZSBtZXRhZGF0YS4gRXhhbXBsZTpcbiAqXG4gKiAgY29uc3QgZ3JhcGggPSB7XG4gKiAgICBjYXJ0OiB7IG1ldGFkYXRhIH1cbiAqICB9O1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKFxuICBzdGF0ZXM6IMm1U3RhdGVDbGFzc0ludGVybmFsW11cbik6IMm1UGxhaW5PYmplY3RPZjzJtVN0YXRlQ2xhc3NJbnRlcm5hbD4ge1xuICByZXR1cm4gc3RhdGVzLnJlZHVjZTzJtVBsYWluT2JqZWN0T2Y8ybVTdGF0ZUNsYXNzSW50ZXJuYWw+PihcbiAgICAocmVzdWx0OiDJtVBsYWluT2JqZWN0T2Y8ybVTdGF0ZUNsYXNzSW50ZXJuYWw+LCBzdGF0ZUNsYXNzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbCkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHN0YXRlQ2xhc3NbybVNRVRBX0tFWV0hO1xuICAgICAgcmVzdWx0W21ldGEubmFtZSFdID0gc3RhdGVDbGFzcztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgb2JqZWN0IHJlbGF0aW9uc2hpcCBncmFwaCB3aWxsIHJldHVybiB0aGUgZnVsbCBwYXRoXG4gKiBmb3IgdGhlIGNoaWxkIGl0ZW1zLiBFeGFtcGxlOlxuICpcbiAqICBjb25zdCBncmFwaCA9IHtcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXG4gKiAgICBpdGVtczogW11cbiAqICB9O1xuICpcbiAqIHdvdWxkIHJldHVybjpcbiAqXG4gKiAgY29uc3QgciA9IHtcbiAqICAgIGNhcnQ6ICdjYXJ0JyxcbiAqICAgIHNhdmVkOiAnY2FydC5zYXZlZCcsXG4gKiAgICBpdGVtczogJ2NhcnQuc2F2ZWQuaXRlbXMnXG4gKiAgfTtcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnVsbFBhcmVudFBhdGgoXG4gIG9iajogU3RhdGVLZXlHcmFwaCxcbiAgbmV3T2JqOiDJtVBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IHt9XG4pOiDJtVBsYWluT2JqZWN0T2Y8c3RyaW5nPiB7XG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KGNoaWxkLCBrZXkpO1xuICAgICAgICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KG9iaiwga2V5KTtcbiAgICAgIG5ld09ialtrZXldID0gcGFyZW50ID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBvYmplY3QgZ3JhcGgsIGl0IHdpbGwgcmV0dXJuIHRoZSBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZCBFeGFtcGxlOlxuICpcbiAqICBjb25zdCBncmFwaCA9IHtcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXG4gKiAgICBpdGVtczogW11cbiAqICB9O1xuICpcbiAqIHdvdWxkIHJldHVybjpcbiAqXG4gKiAgY29uc3QgcmVzdWx0cyA9IFtcbiAqICAgICdpdGVtcycsXG4gKiAgICAnc2F2ZWQnLFxuICogICAgJ2NhcnQnXG4gKiAgXTtcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnQoZ3JhcGg6IFN0YXRlS2V5R3JhcGgpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHNvcnRlZDogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgdmlzaXRlZDogybVQbGFpbk9iamVjdE9mPGJvb2xlYW4+ID0ge307XG5cbiAgY29uc3QgdmlzaXQgPSAobmFtZTogc3RyaW5nLCBhbmNlc3RvcnM6IHN0cmluZ1tdID0gW10pID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xuICAgICAgYW5jZXN0b3JzID0gW107XG4gICAgfVxuXG4gICAgYW5jZXN0b3JzLnB1c2gobmFtZSk7XG4gICAgdmlzaXRlZFtuYW1lXSA9IHRydWU7XG5cbiAgICBncmFwaFtuYW1lXS5mb3JFYWNoKChkZXA6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKE5HX0RFVl9NT0RFICYmIGFuY2VzdG9ycy5pbmRleE9mKGRlcCkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENpcmN1bGFyIGRlcGVuZGVuY3kgJyR7ZGVwfScgaXMgcmVxdWlyZWQgYnkgJyR7bmFtZX0nOiAke2FuY2VzdG9ycy5qb2luKCcgLT4gJyl9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlzaXRlZFtkZXBdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmlzaXQoZGVwLCBhbmNlc3RvcnMuc2xpY2UoMCkpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNvcnRlZC5pbmRleE9mKG5hbWUpIDwgMCkge1xuICAgICAgc29ydGVkLnB1c2gobmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5rZXlzKGdyYXBoKS5mb3JFYWNoKGsgPT4gdmlzaXQoaykpO1xuXG4gIHJldHVybiBzb3J0ZWQucmV2ZXJzZSgpO1xufVxuIl19