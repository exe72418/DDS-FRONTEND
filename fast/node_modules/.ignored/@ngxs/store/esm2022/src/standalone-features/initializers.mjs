import { ENVIRONMENT_INITIALIZER, InjectionToken, inject } from '@angular/core';
import { Store } from '../store';
import { NGXS_PREBOOT_FNS } from './preboot';
import { InitState, UpdateState } from '../plugin_api';
import { FEATURE_STATE_TOKEN, ROOT_STATE_TOKEN } from '../symbols';
import { StateFactory } from '../internal/state-factory';
import { SelectFactory } from '../decorators/select/select-factory';
import { InternalStateOperations } from '../internal/state-operations';
import { LifecycleStateManager } from '../internal/lifecycle-state-manager';
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
/**
 * This function is shared by both NgModule and standalone features.
 * When using `NgxsModule.forRoot` and `provideStore`, we can depend on the
 * same initialization functionality.
 */
export function rootStoreInitializer() {
    const prebootFns = inject(NGXS_PREBOOT_FNS, { optional: true }) || [];
    prebootFns.forEach(prebootFn => prebootFn());
    const factory = inject(StateFactory);
    const internalStateOperations = inject(InternalStateOperations);
    inject(Store);
    inject(SelectFactory);
    const states = inject(ROOT_STATE_TOKEN, { optional: true }) || [];
    const lifecycleStateManager = inject(LifecycleStateManager);
    // Add stores to the state graph and return their defaults.
    const results = factory.addAndReturnDefaults(states);
    internalStateOperations.setStateToTheCurrentWithNew(results);
    // Connect our actions stream.
    factory.connectActionHandlers();
    // Dispatch the init action and invoke init and bootstrap functions after.
    lifecycleStateManager.ngxsBootstrap(new InitState(), results);
}
/**
 * This function is utilized by both NgModule and standalone features.
 * When using `NgxsModule.forFeature` and `provideStates`, we can depend on
 * the same initialization functionality.
 */
export function featureStatesInitializer() {
    inject(Store);
    const internalStateOperations = inject(InternalStateOperations);
    const factory = inject(StateFactory);
    const states = inject(FEATURE_STATE_TOKEN, { optional: true }) || [];
    const lifecycleStateManager = inject(LifecycleStateManager);
    // Since FEATURE_STATE_TOKEN is a multi token, we need to
    // flatten it [[Feature1State, Feature2State], [Feature3State]].
    const flattenedStates = states.reduce((total, values) => total.concat(values), []);
    // add stores to the state graph and return their defaults.
    const results = factory.addAndReturnDefaults(flattenedStates);
    if (results.states.length) {
        internalStateOperations.setStateToTheCurrentWithNew(results);
        // Dispatch the update action and invoke init and bootstrap functions after.
        lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);
    }
}
/**
 * InjectionToken that registers the global Store.
 */
export const NGXS_ROOT_STORE_INITIALIZER = new InjectionToken(NG_DEV_MODE ? 'NGXS_ROOT_STORE_INITIALIZER' : '');
/**
 * InjectionToken that registers feature states.
 */
export const NGXS_FEATURE_STORE_INITIALIZER = new InjectionToken(NG_DEV_MODE ? 'NGXS_FEATURE_STORE_INITIALIZER' : '');
export const NGXS_ROOT_ENVIRONMENT_INITIALIZER = [
    { provide: NGXS_ROOT_STORE_INITIALIZER, useFactory: rootStoreInitializer },
    {
        provide: ENVIRONMENT_INITIALIZER,
        multi: true,
        useFactory() {
            return () => inject(NGXS_ROOT_STORE_INITIALIZER);
        }
    }
];
/**
 * The `NGXS_FEATURE_ENVIRONMENT_INITIALIZER` functions as an environment initializer
 * at the `Route` level. Angular Router creates an environment route injector for each
 * matched route where navigation occurs. The injector is created once, ensuring that
 * the feature states initialization only happens once as well.
 */
export const NGXS_FEATURE_ENVIRONMENT_INITIALIZER = [
    { provide: NGXS_FEATURE_STORE_INITIALIZER, useFactory: featureStatesInitializer },
    {
        provide: ENVIRONMENT_INITIALIZER,
        multi: true,
        useFactory() {
            return () => inject(NGXS_FEATURE_STORE_INITIALIZER);
        }
    }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdGlhbGl6ZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvc3RvcmUvc3JjL3N0YW5kYWxvbmUtZmVhdHVyZXMvaW5pdGlhbGl6ZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxjQUFjLEVBQVksTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzFGLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDakMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQzdDLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNuRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFekQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBRTVFLE1BQU0sV0FBVyxHQUFHLE9BQU8sU0FBUyxLQUFLLFdBQVcsSUFBSSxTQUFTLENBQUM7QUFFbEU7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxvQkFBb0I7SUFDbEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3RFLFVBQVUsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBRTdDLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyQyxNQUFNLHVCQUF1QixH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QjtRQUNoQyxLQUFLLEVBQUUsSUFBSTtRQUNYLFVBQVU7WUFDUixPQUFPLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1FBQ3RELENBQUM7S0FDRjtDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTlZJUk9OTUVOVF9JTklUSUFMSVpFUiwgSW5qZWN0aW9uVG9rZW4sIFByb3ZpZGVyLCBpbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IMm1U3RhdGVDbGFzc0ludGVybmFsIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcblxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICcuLi9zdG9yZSc7XG5pbXBvcnQgeyBOR1hTX1BSRUJPT1RfRk5TIH0gZnJvbSAnLi9wcmVib290JztcbmltcG9ydCB7IEluaXRTdGF0ZSwgVXBkYXRlU3RhdGUgfSBmcm9tICcuLi9wbHVnaW5fYXBpJztcbmltcG9ydCB7IEZFQVRVUkVfU1RBVEVfVE9LRU4sIFJPT1RfU1RBVEVfVE9LRU4gfSBmcm9tICcuLi9zeW1ib2xzJztcbmltcG9ydCB7IFN0YXRlRmFjdG9yeSB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLWZhY3RvcnknO1xuaW1wb3J0IHsgU3RhdGVzQW5kRGVmYXVsdHMgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgU2VsZWN0RmFjdG9yeSB9IGZyb20gJy4uL2RlY29yYXRvcnMvc2VsZWN0L3NlbGVjdC1mYWN0b3J5JztcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMaWZlY3ljbGVTdGF0ZU1hbmFnZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9saWZlY3ljbGUtc3RhdGUtbWFuYWdlcic7XG5cbmNvbnN0IE5HX0RFVl9NT0RFID0gdHlwZW9mIG5nRGV2TW9kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbmdEZXZNb2RlO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIGJ5IGJvdGggTmdNb2R1bGUgYW5kIHN0YW5kYWxvbmUgZmVhdHVyZXMuXG4gKiBXaGVuIHVzaW5nIGBOZ3hzTW9kdWxlLmZvclJvb3RgIGFuZCBgcHJvdmlkZVN0b3JlYCwgd2UgY2FuIGRlcGVuZCBvbiB0aGVcbiAqIHNhbWUgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvb3RTdG9yZUluaXRpYWxpemVyKCk6IHZvaWQge1xuICBjb25zdCBwcmVib290Rm5zID0gaW5qZWN0KE5HWFNfUFJFQk9PVF9GTlMsIHsgb3B0aW9uYWw6IHRydWUgfSkgfHwgW107XG4gIHByZWJvb3RGbnMuZm9yRWFjaChwcmVib290Rm4gPT4gcHJlYm9vdEZuKCkpO1xuXG4gIGNvbnN0IGZhY3RvcnkgPSBpbmplY3QoU3RhdGVGYWN0b3J5KTtcbiAgY29uc3QgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgPSBpbmplY3QoSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMpO1xuXG4gIGluamVjdChTdG9yZSk7XG4gIGluamVjdChTZWxlY3RGYWN0b3J5KTtcblxuICBjb25zdCBzdGF0ZXMgPSBpbmplY3QoUk9PVF9TVEFURV9UT0tFTiwgeyBvcHRpb25hbDogdHJ1ZSB9KSB8fCBbXTtcbiAgY29uc3QgbGlmZWN5Y2xlU3RhdGVNYW5hZ2VyID0gaW5qZWN0KExpZmVjeWNsZVN0YXRlTWFuYWdlcik7XG5cbiAgLy8gQWRkIHN0b3JlcyB0byB0aGUgc3RhdGUgZ3JhcGggYW5kIHJldHVybiB0aGVpciBkZWZhdWx0cy5cbiAgY29uc3QgcmVzdWx0czogU3RhdGVzQW5kRGVmYXVsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlcyk7XG5cbiAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuc2V0U3RhdGVUb1RoZUN1cnJlbnRXaXRoTmV3KHJlc3VsdHMpO1xuXG4gIC8vIENvbm5lY3Qgb3VyIGFjdGlvbnMgc3RyZWFtLlxuICBmYWN0b3J5LmNvbm5lY3RBY3Rpb25IYW5kbGVycygpO1xuXG4gIC8vIERpc3BhdGNoIHRoZSBpbml0IGFjdGlvbiBhbmQgaW52b2tlIGluaXQgYW5kIGJvb3RzdHJhcCBmdW5jdGlvbnMgYWZ0ZXIuXG4gIGxpZmVjeWNsZVN0YXRlTWFuYWdlci5uZ3hzQm9vdHN0cmFwKG5ldyBJbml0U3RhdGUoKSwgcmVzdWx0cyk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1dGlsaXplZCBieSBib3RoIE5nTW9kdWxlIGFuZCBzdGFuZGFsb25lIGZlYXR1cmVzLlxuICogV2hlbiB1c2luZyBgTmd4c01vZHVsZS5mb3JGZWF0dXJlYCBhbmQgYHByb3ZpZGVTdGF0ZXNgLCB3ZSBjYW4gZGVwZW5kIG9uXG4gKiB0aGUgc2FtZSBpbml0aWFsaXphdGlvbiBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmVhdHVyZVN0YXRlc0luaXRpYWxpemVyKCk6IHZvaWQge1xuICBpbmplY3QoU3RvcmUpO1xuXG4gIGNvbnN0IGludGVybmFsU3RhdGVPcGVyYXRpb25zID0gaW5qZWN0KEludGVybmFsU3RhdGVPcGVyYXRpb25zKTtcbiAgY29uc3QgZmFjdG9yeSA9IGluamVjdChTdGF0ZUZhY3RvcnkpO1xuICBjb25zdCBzdGF0ZXMgPSBpbmplY3QoRkVBVFVSRV9TVEFURV9UT0tFTiwgeyBvcHRpb25hbDogdHJ1ZSB9KSB8fCBbXTtcbiAgY29uc3QgbGlmZWN5Y2xlU3RhdGVNYW5hZ2VyID0gaW5qZWN0KExpZmVjeWNsZVN0YXRlTWFuYWdlcik7XG5cbiAgLy8gU2luY2UgRkVBVFVSRV9TVEFURV9UT0tFTiBpcyBhIG11bHRpIHRva2VuLCB3ZSBuZWVkIHRvXG4gIC8vIGZsYXR0ZW4gaXQgW1tGZWF0dXJlMVN0YXRlLCBGZWF0dXJlMlN0YXRlXSwgW0ZlYXR1cmUzU3RhdGVdXS5cbiAgY29uc3QgZmxhdHRlbmVkU3RhdGVzOiDJtVN0YXRlQ2xhc3NJbnRlcm5hbFtdID0gc3RhdGVzLnJlZHVjZShcbiAgICAodG90YWw6IMm1U3RhdGVDbGFzc0ludGVybmFsW10sIHZhbHVlczogybVTdGF0ZUNsYXNzSW50ZXJuYWxbXSkgPT4gdG90YWwuY29uY2F0KHZhbHVlcyksXG4gICAgW11cbiAgKTtcblxuICAvLyBhZGQgc3RvcmVzIHRvIHRoZSBzdGF0ZSBncmFwaCBhbmQgcmV0dXJuIHRoZWlyIGRlZmF1bHRzLlxuICBjb25zdCByZXN1bHRzOiBTdGF0ZXNBbmREZWZhdWx0cyA9IGZhY3RvcnkuYWRkQW5kUmV0dXJuRGVmYXVsdHMoZmxhdHRlbmVkU3RhdGVzKTtcblxuICBpZiAocmVzdWx0cy5zdGF0ZXMubGVuZ3RoKSB7XG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuc2V0U3RhdGVUb1RoZUN1cnJlbnRXaXRoTmV3KHJlc3VsdHMpO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHVwZGF0ZSBhY3Rpb24gYW5kIGludm9rZSBpbml0IGFuZCBib290c3RyYXAgZnVuY3Rpb25zIGFmdGVyLlxuICAgIGxpZmVjeWNsZVN0YXRlTWFuYWdlci5uZ3hzQm9vdHN0cmFwKG5ldyBVcGRhdGVTdGF0ZShyZXN1bHRzLmRlZmF1bHRzKSwgcmVzdWx0cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmplY3Rpb25Ub2tlbiB0aGF0IHJlZ2lzdGVycyB0aGUgZ2xvYmFsIFN0b3JlLlxuICovXG5leHBvcnQgY29uc3QgTkdYU19ST09UX1NUT1JFX0lOSVRJQUxJWkVSID0gbmV3IEluamVjdGlvblRva2VuPHZvaWQ+KFxuICBOR19ERVZfTU9ERSA/ICdOR1hTX1JPT1RfU1RPUkVfSU5JVElBTElaRVInIDogJydcbik7XG5cbi8qKlxuICogSW5qZWN0aW9uVG9rZW4gdGhhdCByZWdpc3RlcnMgZmVhdHVyZSBzdGF0ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBOR1hTX0ZFQVRVUkVfU1RPUkVfSU5JVElBTElaRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW48dm9pZD4oXG4gIE5HX0RFVl9NT0RFID8gJ05HWFNfRkVBVFVSRV9TVE9SRV9JTklUSUFMSVpFUicgOiAnJ1xuKTtcblxuZXhwb3J0IGNvbnN0IE5HWFNfUk9PVF9FTlZJUk9OTUVOVF9JTklUSUFMSVpFUjogUHJvdmlkZXJbXSA9IFtcbiAgeyBwcm92aWRlOiBOR1hTX1JPT1RfU1RPUkVfSU5JVElBTElaRVIsIHVzZUZhY3Rvcnk6IHJvb3RTdG9yZUluaXRpYWxpemVyIH0sXG4gIHtcbiAgICBwcm92aWRlOiBFTlZJUk9OTUVOVF9JTklUSUFMSVpFUixcbiAgICBtdWx0aTogdHJ1ZSxcbiAgICB1c2VGYWN0b3J5KCkge1xuICAgICAgcmV0dXJuICgpID0+IGluamVjdChOR1hTX1JPT1RfU1RPUkVfSU5JVElBTElaRVIpO1xuICAgIH1cbiAgfVxuXTtcblxuLyoqXG4gKiBUaGUgYE5HWFNfRkVBVFVSRV9FTlZJUk9OTUVOVF9JTklUSUFMSVpFUmAgZnVuY3Rpb25zIGFzIGFuIGVudmlyb25tZW50IGluaXRpYWxpemVyXG4gKiBhdCB0aGUgYFJvdXRlYCBsZXZlbC4gQW5ndWxhciBSb3V0ZXIgY3JlYXRlcyBhbiBlbnZpcm9ubWVudCByb3V0ZSBpbmplY3RvciBmb3IgZWFjaFxuICogbWF0Y2hlZCByb3V0ZSB3aGVyZSBuYXZpZ2F0aW9uIG9jY3Vycy4gVGhlIGluamVjdG9yIGlzIGNyZWF0ZWQgb25jZSwgZW5zdXJpbmcgdGhhdFxuICogdGhlIGZlYXR1cmUgc3RhdGVzIGluaXRpYWxpemF0aW9uIG9ubHkgaGFwcGVucyBvbmNlIGFzIHdlbGwuXG4gKi9cbmV4cG9ydCBjb25zdCBOR1hTX0ZFQVRVUkVfRU5WSVJPTk1FTlRfSU5JVElBTElaRVI6IFByb3ZpZGVyW10gPSBbXG4gIHsgcHJvdmlkZTogTkdYU19GRUFUVVJFX1NUT1JFX0lOSVRJQUxJWkVSLCB1c2VGYWN0b3J5OiBmZWF0dXJlU3RhdGVzSW5pdGlhbGl6ZXIgfSxcbiAge1xuICAgIHByb3ZpZGU6IEVOVklST05NRU5UX0lOSVRJQUxJWkVSLFxuICAgIG11bHRpOiB0cnVlLFxuICAgIHVzZUZhY3RvcnkoKSB7XG4gICAgICByZXR1cm4gKCkgPT4gaW5qZWN0KE5HWFNfRkVBVFVSRV9TVE9SRV9JTklUSUFMSVpFUik7XG4gICAgfVxuICB9XG5dO1xuIl19