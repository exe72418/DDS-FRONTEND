import { InjectionToken, Type } from '@angular/core';
import { Observable } from 'rxjs';
import { StateOperator } from '@ngxs/store/operators';
import { ɵSharedSelectorOptions, ɵStateClass } from '@ngxs/store/internals';
import { NgxsExecutionStrategy } from './execution/symbols';
import * as i0 from "@angular/core";
export declare const ROOT_STATE_TOKEN: InjectionToken<ɵStateClass[]>;
export declare const FEATURE_STATE_TOKEN: InjectionToken<ɵStateClass[][]>;
export declare const NGXS_OPTIONS: InjectionToken<Partial<NgxsConfig>>;
export type NgxsLifeCycle = Partial<NgxsOnChanges> & Partial<NgxsOnInit> & Partial<NgxsAfterBootstrap>;
/**
 * The NGXS config settings.
 */
export declare class NgxsConfig {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     *
     * Note: this property will be accounted only in development mode.
     * It makes sense to use it only during development to ensure there're no state mutations.
     * When building for production, the `Object.freeze` will be tree-shaken away.
     */
    developmentMode: boolean;
    compatibility: {
        /**
         * Support a strict Content Security Policy.
         * This will circumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.
         * (default: false)
         */
        strictContentSecurityPolicy: boolean;
    };
    /**
     * Determines the execution context to perform async operations inside. An implementation can be
     * provided to override the default behaviour where the async operations are run
     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.
     * These observable behaviours are from:
     *   `store.selectSignal(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`
     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your
     * application doesn't rely on zone.js running change detection then you can switch to the
     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.
     * (default: null)
     */
    executionStrategy: Type<NgxsExecutionStrategy>;
    /**
     * Defining shared selector options
     */
    selectorOptions: ɵSharedSelectorOptions;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsConfig, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NgxsConfig>;
}
export { StateOperator };
/**
 * State context provided to the actions in the state.
 */
export interface StateContext<T> {
    /**
     * Get the current state.
     */
    getState(): T;
    /**
     * Reset the state to a new value.
     */
    setState(val: T | StateOperator<T>): void;
    /**
     * Patch the existing state with the provided value.
     */
    patchState(val: Partial<T>): void;
    /**
     * Dispatch a new action and return the dispatched observable.
     */
    dispatch(actions: any | any[]): Observable<void>;
}
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 */
export declare class NgxsSimpleChange<T = any> {
    readonly previousValue: T;
    readonly currentValue: T;
    readonly firstChange: boolean;
    constructor(previousValue: T, currentValue: T, firstChange: boolean);
}
/**
 * On init interface
 */
export interface NgxsOnInit {
    ngxsOnInit(ctx: StateContext<any>): void;
}
/**
 * On change interface
 */
export interface NgxsOnChanges {
    ngxsOnChanges(change: NgxsSimpleChange): void;
}
/**
 * After bootstrap interface
 */
export interface NgxsAfterBootstrap {
    ngxsAfterBootstrap(ctx: StateContext<any>): void;
}
export type NgxsModuleOptions = Partial<NgxsConfig>;
