import { PLATFORM_ID, Inject, Injectable, inject } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import { setValue, getValue, InitState, UpdateState, actionMatcher } from '@ngxs/store/plugins';
import { ɵDEFAULT_STATE_KEY, ɵALL_STATES_PERSISTED, ɵNGXS_STORAGE_PLUGIN_OPTIONS } from '@ngxs/storage-plugin/internals';
import { tap } from 'rxjs/operators';
import { getStorageKey } from './internals';
import { ɵNgxsStoragePluginKeysManager } from './keys-manager';
import * as i0 from "@angular/core";
import * as i1 from "./keys-manager";
const NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;
export class NgxsStoragePlugin {
    constructor(_keysManager, _options, _platformId) {
        this._keysManager = _keysManager;
        this._options = _options;
        this._platformId = _platformId;
        this._allStatesPersisted = inject(ɵALL_STATES_PERSISTED);
    }
    handle(state, event, next) {
        if (isPlatformServer(this._platformId)) {
            return next(state, event);
        }
        const matches = actionMatcher(event);
        const isInitAction = matches(InitState);
        const isUpdateAction = matches(UpdateState);
        const isInitOrUpdateAction = isInitAction || isUpdateAction;
        let hasMigration = false;
        if (isInitOrUpdateAction) {
            const addedStates = isUpdateAction && event.addedStates;
            for (const { key, engine } of this._keysManager.getKeysWithEngines()) {
                // We're checking what states have been added by NGXS and if any of these states should be handled by
                // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added
                // the `user` state, the storage plugin will be rerun and will do redundant deserialization.
                // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.
                if (!this._allStatesPersisted && addedStates) {
                    // We support providing keys that can be deeply nested via dot notation, for instance,
                    // `keys: ['myState.myProperty']` is a valid key.
                    // The state name should always go first. The below code checks if the `key` includes dot
                    // notation and extracts the state name out of the key.
                    // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.
                    const dotNotationIndex = key.indexOf(DOT);
                    const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;
                    if (!addedStates.hasOwnProperty(stateName)) {
                        continue;
                    }
                }
                const storageKey = getStorageKey(key, this._options);
                let storedValue = engine.getItem(storageKey);
                if (storedValue !== 'undefined' && storedValue != null) {
                    try {
                        const newVal = this._options.deserialize(storedValue);
                        storedValue = this._options.afterDeserialize(newVal, key);
                    }
                    catch {
                        NG_DEV_MODE &&
                            console.error(`Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `, storedValue);
                        storedValue = {};
                    }
                    this._options.migrations?.forEach(strategy => {
                        const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');
                        const keyMatch = (!strategy.key && this._allStatesPersisted) || strategy.key === key;
                        if (versionMatch && keyMatch) {
                            storedValue = strategy.migrate(storedValue);
                            hasMigration = true;
                        }
                    });
                    if (this._allStatesPersisted) {
                        storedValue = this._hydrateSelectivelyOnUpdate(storedValue, addedStates);
                        state = { ...state, ...storedValue };
                    }
                    else {
                        state = setValue(state, key, storedValue);
                    }
                }
            }
        }
        return next(state, event).pipe(tap(nextState => {
            if (isInitOrUpdateAction && !hasMigration) {
                return;
            }
            for (const { key, engine } of this._keysManager.getKeysWithEngines()) {
                let storedValue = nextState;
                const storageKey = getStorageKey(key, this._options);
                if (key !== ɵDEFAULT_STATE_KEY) {
                    storedValue = getValue(nextState, key);
                }
                try {
                    const newStoredValue = this._options.beforeSerialize(storedValue, key);
                    engine.setItem(storageKey, this._options.serialize(newStoredValue));
                }
                catch (error) {
                    if (NG_DEV_MODE) {
                        if (error &&
                            (error.name === 'QuotaExceededError' ||
                                error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
                            console.error(`The ${storageKey} store value exceeds the browser storage quota: `, storedValue);
                        }
                        else {
                            console.error(`Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `, storedValue);
                        }
                    }
                }
            }
        }));
    }
    _hydrateSelectivelyOnUpdate(storedValue, addedStates) {
        // The `UpdateState` action is triggered whenever a feature state is added.
        // The condition below is only satisfied when this action is triggered.
        // Let's consider two states: `counter` and `@ngxs/router-plugin` state.
        // When `provideStore` is called, `CounterState` is provided at the root level,
        // while `@ngxs/router-plugin` is provided as a feature state. Previously, the storage
        // plugin might have stored the value of the counter state as `10`. If `CounterState`
        // implements the `ngxsOnInit` hook and sets the state to `999`, the storage plugin will
        // reset the entire state when the `RouterState` is registered.
        // Consequently, the `counter` state will revert back to `10` instead of `999`.
        if (!storedValue || !addedStates || Object.keys(addedStates).length === 0) {
            // Nothing to update if `addedStates` object is empty.
            return storedValue;
        }
        // The `storedValue` can be the entire state when the default state key
        // is used. However, if `addedStates` only contains the `router` value,
        // we only want to merge the state with that `router` value.
        // Given the `storedValue` is an object:
        // `{ counter: 10, router: {...} }`
        // This will only select the `router` object from the `storedValue`,
        // avoiding unnecessary rehydration of the `counter` state.
        return Object.keys(addedStates).reduce((accumulator, addedState) => {
            if (storedValue.hasOwnProperty(addedState)) {
                accumulator[addedState] = storedValue[addedState];
            }
            return accumulator;
        }, {});
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: NgxsStoragePlugin, deps: [{ token: i1.ɵNgxsStoragePluginKeysManager }, { token: ɵNGXS_STORAGE_PLUGIN_OPTIONS }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: NgxsStoragePlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: NgxsStoragePlugin, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.ɵNgxsStoragePluginKeysManager }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [ɵNGXS_STORAGE_PLUGIN_OPTIONS]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }] });
const DOT = '.';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS5wbHVnaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yYWdlLXBsdWdpbi9zcmMvc3RvcmFnZS5wbHVnaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUVuRCxPQUFPLEVBRUwsUUFBUSxFQUNSLFFBQVEsRUFDUixTQUFTLEVBQ1QsV0FBVyxFQUNYLGFBQWEsRUFFZCxNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFDTCxrQkFBa0IsRUFDbEIscUJBQXFCLEVBRXJCLDRCQUE0QixFQUM3QixNQUFNLGdDQUFnQyxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzVDLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFJL0QsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUdsRSxNQUFNLE9BQU8saUJBQWlCO0lBRzVCLFlBQ1UsWUFBMkMsRUFDTCxRQUFrQyxFQUNuRCxXQUFtQjtRQUZ4QyxpQkFBWSxHQUFaLFlBQVksQ0FBK0I7UUFDTCxhQUFRLEdBQVIsUUFBUSxDQUEwQjtRQUNuRCxnQkFBVyxHQUFYLFdBQVcsQ0FBUTtRQUwxQyx3QkFBbUIsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQU16RCxDQUFDO0lBRUosTUFBTSxDQUFDLEtBQVUsRUFBRSxLQUFVLEVBQUUsSUFBc0I7UUFDbkQsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FB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LENBQUMsRUFBRSxDQUFDO2dCQUMzQyxXQUFXLENBQUMsVUFBVSxDQUFDLEdBQUcsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BELENBQUM7WUFDRCxPQUFPLFdBQVcsQ0FBQztRQUNyQixDQUFDLEVBQ2EsRUFBRSxDQUNqQixDQUFDO0lBQ0osQ0FBQztpSUF6SlUsaUJBQWlCLCtEQUtsQiw0QkFBNEIsYUFDNUIsV0FBVztxSUFOVixpQkFBaUI7OzJGQUFqQixpQkFBaUI7a0JBRDdCLFVBQVU7OzBCQU1OLE1BQU07MkJBQUMsNEJBQTRCOzswQkFDbkMsTUFBTTsyQkFBQyxXQUFXOztBQXNKdkIsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdCwgSW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtU2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IMm1UGxhaW5PYmplY3QgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuaW1wb3J0IHtcbiAgTmd4c1BsdWdpbixcbiAgc2V0VmFsdWUsXG4gIGdldFZhbHVlLFxuICBJbml0U3RhdGUsXG4gIFVwZGF0ZVN0YXRlLFxuICBhY3Rpb25NYXRjaGVyLFxuICBOZ3hzTmV4dFBsdWdpbkZuXG59IGZyb20gJ0BuZ3hzL3N0b3JlL3BsdWdpbnMnO1xuaW1wb3J0IHtcbiAgybVERUZBVUxUX1NUQVRFX0tFWSxcbiAgybVBTExfU1RBVEVTX1BFUlNJU1RFRCxcbiAgTmd4c1N0b3JhZ2VQbHVnaW5PcHRpb25zLFxuICDJtU5HWFNfU1RPUkFHRV9QTFVHSU5fT1BUSU9OU1xufSBmcm9tICdAbmd4cy9zdG9yYWdlLXBsdWdpbi9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBnZXRTdG9yYWdlS2V5IH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgybVOZ3hzU3RvcmFnZVBsdWdpbktleXNNYW5hZ2VyIH0gZnJvbSAnLi9rZXlzLW1hbmFnZXInO1xuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlICE9PSAndW5kZWZpbmVkJyAmJiBuZ0Rldk1vZGU7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ3hzU3RvcmFnZVBsdWdpbiBpbXBsZW1lbnRzIE5neHNQbHVnaW4ge1xuICBwcml2YXRlIF9hbGxTdGF0ZXNQZXJzaXN0ZWQgPSBpbmplY3QoybVBTExfU1RBVEVTX1BFUlNJU1RFRCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfa2V5c01hbmFnZXI6IMm1Tmd4c1N0b3JhZ2VQbHVnaW5LZXlzTWFuYWdlcixcbiAgICBASW5qZWN0KMm1TkdYU19TVE9SQUdFX1BMVUdJTl9PUFRJT05TKSBwcml2YXRlIF9vcHRpb25zOiBOZ3hzU3RvcmFnZVBsdWdpbk9wdGlvbnMsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBfcGxhdGZvcm1JZDogc3RyaW5nXG4gICkge31cblxuICBoYW5kbGUoc3RhdGU6IGFueSwgZXZlbnQ6IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5Gbikge1xuICAgIGlmIChpc1BsYXRmb3JtU2VydmVyKHRoaXMuX3BsYXRmb3JtSWQpKSB7XG4gICAgICByZXR1cm4gbmV4dChzdGF0ZSwgZXZlbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoZXMgPSBhY3Rpb25NYXRjaGVyKGV2ZW50KTtcbiAgICBjb25zdCBpc0luaXRBY3Rpb24gPSBtYXRjaGVzKEluaXRTdGF0ZSk7XG4gICAgY29uc3QgaXNVcGRhdGVBY3Rpb24gPSBtYXRjaGVzKFVwZGF0ZVN0YXRlKTtcbiAgICBjb25zdCBpc0luaXRPclVwZGF0ZUFjdGlvbiA9IGlzSW5pdEFjdGlvbiB8fCBpc1VwZGF0ZUFjdGlvbjtcbiAgICBsZXQgaGFzTWlncmF0aW9uID0gZmFsc2U7XG5cbiAgICBpZiAoaXNJbml0T3JVcGRhdGVBY3Rpb24pIHtcbiAgICAgIGNvbnN0IGFkZGVkU3RhdGVzOiDJtVBsYWluT2JqZWN0ID0gaXNVcGRhdGVBY3Rpb24gJiYgZXZlbnQuYWRkZWRTdGF0ZXM7XG5cbiAgICAgIGZvciAoY29uc3QgeyBrZXksIGVuZ2luZSB9IG9mIHRoaXMuX2tleXNNYW5hZ2VyLmdldEtleXNXaXRoRW5naW5lcygpKSB7XG4gICAgICAgIC8vIFdlJ3JlIGNoZWNraW5nIHdoYXQgc3RhdGVzIGhhdmUgYmVlbiBhZGRlZCBieSBOR1hTIGFuZCBpZiBhbnkgb2YgdGhlc2Ugc3RhdGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5XG4gICAgICAgIC8vIHRoZSBzdG9yYWdlIHBsdWdpbi4gRm9yIGluc3RhbmNlLCB3ZSBvbmx5IHdhbnQgdG8gZGVzZXJpYWxpemUgdGhlIGBhdXRoYCBzdGF0ZSwgTkdYUyBoYXMgYWRkZWRcbiAgICAgICAgLy8gdGhlIGB1c2VyYCBzdGF0ZSwgdGhlIHN0b3JhZ2UgcGx1Z2luIHdpbGwgYmUgcmVydW4gYW5kIHdpbGwgZG8gcmVkdW5kYW50IGRlc2VyaWFsaXphdGlvbi5cbiAgICAgICAgLy8gYHVzZXNEZWZhdWx0U3RhdGVLZXlgIGlzIG5lY2Vzc2FyeSB0byBjaGVjayBzaW5jZSBgZXZlbnQuYWRkZWRTdGF0ZXNgIG5ldmVyIGNvbnRhaW5zIGBAQFNUQVRFYC5cbiAgICAgICAgaWYgKCF0aGlzLl9hbGxTdGF0ZXNQZXJzaXN0ZWQgJiYgYWRkZWRTdGF0ZXMpIHtcbiAgICAgICAgICAvLyBXZSBzdXBwb3J0IHByb3ZpZGluZyBrZXlzIHRoYXQgY2FuIGJlIGRlZXBseSBuZXN0ZWQgdmlhIGRvdCBub3RhdGlvbiwgZm9yIGluc3RhbmNlLFxuICAgICAgICAgIC8vIGBrZXlzOiBbJ215U3RhdGUubXlQcm9wZXJ0eSddYCBpcyBhIHZhbGlkIGtleS5cbiAgICAgICAgICAvLyBUaGUgc3RhdGUgbmFtZSBzaG91bGQgYWx3YXlzIGdvIGZpcnN0LiBUaGUgYmVsb3cgY29kZSBjaGVja3MgaWYgdGhlIGBrZXlgIGluY2x1ZGVzIGRvdFxuICAgICAgICAgIC8vIG5vdGF0aW9uIGFuZCBleHRyYWN0cyB0aGUgc3RhdGUgbmFtZSBvdXQgb2YgdGhlIGtleS5cbiAgICAgICAgICAvLyBHaXZlbiB0aGUgYGtleWAgaXMgYG15U3RhdGUubXlQcm9wZXJ0eWAsIHRoZSBgYWRkZWRTdGF0ZXNgIHdpbGwgb25seSBjb250YWluIGBteVN0YXRlYC5cbiAgICAgICAgICBjb25zdCBkb3ROb3RhdGlvbkluZGV4ID0ga2V5LmluZGV4T2YoRE9UKTtcbiAgICAgICAgICBjb25zdCBzdGF0ZU5hbWUgPSBkb3ROb3RhdGlvbkluZGV4ID4gLTEgPyBrZXkuc2xpY2UoMCwgZG90Tm90YXRpb25JbmRleCkgOiBrZXk7XG4gICAgICAgICAgaWYgKCFhZGRlZFN0YXRlcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZU5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yYWdlS2V5ID0gZ2V0U3RvcmFnZUtleShrZXksIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICBsZXQgc3RvcmVkVmFsdWU6IGFueSA9IGVuZ2luZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuXG4gICAgICAgIGlmIChzdG9yZWRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RvcmVkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWwgPSB0aGlzLl9vcHRpb25zLmRlc2VyaWFsaXplIShzdG9yZWRWYWx1ZSk7XG4gICAgICAgICAgICBzdG9yZWRWYWx1ZSA9IHRoaXMuX29wdGlvbnMuYWZ0ZXJEZXNlcmlhbGl6ZSEobmV3VmFsLCBrZXkpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgTkdfREVWX01PREUgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBgRXJyb3Igb2N1cnJlZCB3aGlsZSBkZXNlcmlhbGl6aW5nIHRoZSAke3N0b3JhZ2VLZXl9IHN0b3JlIHZhbHVlLCBmYWxsaW5nIGJhY2sgdG8gZW1wdHkgb2JqZWN0LCB0aGUgdmFsdWUgb2J0YWluZWQgZnJvbSB0aGUgc3RvcmU6IGAsXG4gICAgICAgICAgICAgICAgc3RvcmVkVmFsdWVcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc3RvcmVkVmFsdWUgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9vcHRpb25zLm1pZ3JhdGlvbnM/LmZvckVhY2goc3RyYXRlZ3kgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID1cbiAgICAgICAgICAgICAgc3RyYXRlZ3kudmVyc2lvbiA9PT0gZ2V0VmFsdWUoc3RvcmVkVmFsdWUsIHN0cmF0ZWd5LnZlcnNpb25LZXkgfHwgJ3ZlcnNpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IGtleU1hdGNoID1cbiAgICAgICAgICAgICAgKCFzdHJhdGVneS5rZXkgJiYgdGhpcy5fYWxsU3RhdGVzUGVyc2lzdGVkKSB8fCBzdHJhdGVneS5rZXkgPT09IGtleTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uTWF0Y2ggJiYga2V5TWF0Y2gpIHtcbiAgICAgICAgICAgICAgc3RvcmVkVmFsdWUgPSBzdHJhdGVneS5taWdyYXRlKHN0b3JlZFZhbHVlKTtcbiAgICAgICAgICAgICAgaGFzTWlncmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLl9hbGxTdGF0ZXNQZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgIHN0b3JlZFZhbHVlID0gdGhpcy5faHlkcmF0ZVNlbGVjdGl2ZWx5T25VcGRhdGUoc3RvcmVkVmFsdWUsIGFkZGVkU3RhdGVzKTtcbiAgICAgICAgICAgIHN0YXRlID0geyAuLi5zdGF0ZSwgLi4uc3RvcmVkVmFsdWUgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwga2V5LCBzdG9yZWRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQoc3RhdGUsIGV2ZW50KS5waXBlKFxuICAgICAgdGFwKG5leHRTdGF0ZSA9PiB7XG4gICAgICAgIGlmIChpc0luaXRPclVwZGF0ZUFjdGlvbiAmJiAhaGFzTWlncmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB7IGtleSwgZW5naW5lIH0gb2YgdGhpcy5fa2V5c01hbmFnZXIuZ2V0S2V5c1dpdGhFbmdpbmVzKCkpIHtcbiAgICAgICAgICBsZXQgc3RvcmVkVmFsdWUgPSBuZXh0U3RhdGU7XG5cbiAgICAgICAgICBjb25zdCBzdG9yYWdlS2V5ID0gZ2V0U3RvcmFnZUtleShrZXksIHRoaXMuX29wdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKGtleSAhPT0gybVERUZBVUxUX1NUQVRFX0tFWSkge1xuICAgICAgICAgICAgc3RvcmVkVmFsdWUgPSBnZXRWYWx1ZShuZXh0U3RhdGUsIGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0b3JlZFZhbHVlID0gdGhpcy5fb3B0aW9ucy5iZWZvcmVTZXJpYWxpemUhKHN0b3JlZFZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgZW5naW5lLnNldEl0ZW0oc3RvcmFnZUtleSwgdGhpcy5fb3B0aW9ucy5zZXJpYWxpemUhKG5ld1N0b3JlZFZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBlcnJvciAmJlxuICAgICAgICAgICAgICAgIChlcnJvci5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJyB8fFxuICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9PT0gJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIGBUaGUgJHtzdG9yYWdlS2V5fSBzdG9yZSB2YWx1ZSBleGNlZWRzIHRoZSBicm93c2VyIHN0b3JhZ2UgcXVvdGE6IGAsXG4gICAgICAgICAgICAgICAgICBzdG9yZWRWYWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIGBFcnJvciBvY3VycmVkIHdoaWxlIHNlcmlhbGl6aW5nIHRoZSAke3N0b3JhZ2VLZXl9IHN0b3JlIHZhbHVlLCB2YWx1ZSBub3QgdXBkYXRlZCwgdGhlIHZhbHVlIG9idGFpbmVkIGZyb20gdGhlIHN0b3JlOiBgLFxuICAgICAgICAgICAgICAgICAgc3RvcmVkVmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIF9oeWRyYXRlU2VsZWN0aXZlbHlPblVwZGF0ZShzdG9yZWRWYWx1ZTogYW55LCBhZGRlZFN0YXRlczogybVQbGFpbk9iamVjdCkge1xuICAgIC8vIFRoZSBgVXBkYXRlU3RhdGVgIGFjdGlvbiBpcyB0cmlnZ2VyZWQgd2hlbmV2ZXIgYSBmZWF0dXJlIHN0YXRlIGlzIGFkZGVkLlxuICAgIC8vIFRoZSBjb25kaXRpb24gYmVsb3cgaXMgb25seSBzYXRpc2ZpZWQgd2hlbiB0aGlzIGFjdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgLy8gTGV0J3MgY29uc2lkZXIgdHdvIHN0YXRlczogYGNvdW50ZXJgIGFuZCBgQG5neHMvcm91dGVyLXBsdWdpbmAgc3RhdGUuXG4gICAgLy8gV2hlbiBgcHJvdmlkZVN0b3JlYCBpcyBjYWxsZWQsIGBDb3VudGVyU3RhdGVgIGlzIHByb3ZpZGVkIGF0IHRoZSByb290IGxldmVsLFxuICAgIC8vIHdoaWxlIGBAbmd4cy9yb3V0ZXItcGx1Z2luYCBpcyBwcm92aWRlZCBhcyBhIGZlYXR1cmUgc3RhdGUuIFByZXZpb3VzbHksIHRoZSBzdG9yYWdlXG4gICAgLy8gcGx1Z2luIG1pZ2h0IGhhdmUgc3RvcmVkIHRoZSB2YWx1ZSBvZiB0aGUgY291bnRlciBzdGF0ZSBhcyBgMTBgLiBJZiBgQ291bnRlclN0YXRlYFxuICAgIC8vIGltcGxlbWVudHMgdGhlIGBuZ3hzT25Jbml0YCBob29rIGFuZCBzZXRzIHRoZSBzdGF0ZSB0byBgOTk5YCwgdGhlIHN0b3JhZ2UgcGx1Z2luIHdpbGxcbiAgICAvLyByZXNldCB0aGUgZW50aXJlIHN0YXRlIHdoZW4gdGhlIGBSb3V0ZXJTdGF0ZWAgaXMgcmVnaXN0ZXJlZC5cbiAgICAvLyBDb25zZXF1ZW50bHksIHRoZSBgY291bnRlcmAgc3RhdGUgd2lsbCByZXZlcnQgYmFjayB0byBgMTBgIGluc3RlYWQgb2YgYDk5OWAuXG5cbiAgICBpZiAoIXN0b3JlZFZhbHVlIHx8ICFhZGRlZFN0YXRlcyB8fCBPYmplY3Qua2V5cyhhZGRlZFN0YXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIHVwZGF0ZSBpZiBgYWRkZWRTdGF0ZXNgIG9iamVjdCBpcyBlbXB0eS5cbiAgICAgIHJldHVybiBzdG9yZWRWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBUaGUgYHN0b3JlZFZhbHVlYCBjYW4gYmUgdGhlIGVudGlyZSBzdGF0ZSB3aGVuIHRoZSBkZWZhdWx0IHN0YXRlIGtleVxuICAgIC8vIGlzIHVzZWQuIEhvd2V2ZXIsIGlmIGBhZGRlZFN0YXRlc2Agb25seSBjb250YWlucyB0aGUgYHJvdXRlcmAgdmFsdWUsXG4gICAgLy8gd2Ugb25seSB3YW50IHRvIG1lcmdlIHRoZSBzdGF0ZSB3aXRoIHRoYXQgYHJvdXRlcmAgdmFsdWUuXG4gICAgLy8gR2l2ZW4gdGhlIGBzdG9yZWRWYWx1ZWAgaXMgYW4gb2JqZWN0OlxuICAgIC8vIGB7IGNvdW50ZXI6IDEwLCByb3V0ZXI6IHsuLi59IH1gXG4gICAgLy8gVGhpcyB3aWxsIG9ubHkgc2VsZWN0IHRoZSBgcm91dGVyYCBvYmplY3QgZnJvbSB0aGUgYHN0b3JlZFZhbHVlYCxcbiAgICAvLyBhdm9pZGluZyB1bm5lY2Vzc2FyeSByZWh5ZHJhdGlvbiBvZiB0aGUgYGNvdW50ZXJgIHN0YXRlLlxuICAgIHJldHVybiBPYmplY3Qua2V5cyhhZGRlZFN0YXRlcykucmVkdWNlKFxuICAgICAgKGFjY3VtdWxhdG9yLCBhZGRlZFN0YXRlKSA9PiB7XG4gICAgICAgIGlmIChzdG9yZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShhZGRlZFN0YXRlKSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yW2FkZGVkU3RhdGVdID0gc3RvcmVkVmFsdWVbYWRkZWRTdGF0ZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgfSxcbiAgICAgIDzJtVBsYWluT2JqZWN0Pnt9XG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBET1QgPSAnLic7XG4iXX0=